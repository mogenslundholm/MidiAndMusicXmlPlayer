//---------------------------------------------------------------------------
//
//  Program:     MidiAndMusicXmlPlayer.exe (Windows)
//               MidiAndMusicXmlPlayer.app (Mac)
//
//  Copyright:   By Mogens Lundholm alias Magnus Lind
//               The program may be copied under these
//               conditions: 1. The style is not altered, indentions, name
//               style etc. To this copyright notice the change description
//               is added
//
//  Project:     MidiAndMusicXmlPlayer.dpr / MidiAndMusicXmlPlayer.dproj
//               / MidiAndMusicXmlPlayer.lpi
//
//  Purpose:     To play a midi file format 0 or format 1 and MusicXml-files
//               Possibility to
//               select tracks and speed and transpose the midi file
//
//  Compilation: Compile with Delphi 4 (MidiAndMusicXmlPlayer.dpr) or
//               Lazarus (MidiAndMusicXmlPlayer.lpi)
//               or Delphi XE (MidiAndMusicXmlPlayer.dproj)
//
//  Description: From the midi file an array of events are build. The events
//               are only "short message", i.e. notes and control setting.
//               The meta events are skipped except data used for openoptions
//               printout (Name of song + track names.
//
//  Documents:   Score.ppt: Layout of a note page
//               XmlScorePartwise.odp: State diagram for XML, part 1
//               XmlPart.odp: State diagram for XML, part 2
//               Problems.txt: Not solved problems
//               Testplan.txt: How to test MidiAndMusicXmlPlayer.exe
//
//  Version:     The MenuItemAboutClick procedure uses the value VersionText defined
//               in UnitMidiDefinitions
//---------------------------------------------------------------------------

unit UnitMidiGui;


{$ifdef FPC}
{$MODE Delphi}
{$endif}

{$ifdef Darwin}
{$modeswitch objectivec1}
{$endif}

interface

uses
{$ifndef FPC}
  shlobj, ActiveX, // ComObj, // For install
  Windows,
  ShellApi,
  FileCtrl,
{$else}
  LCLIntf, LCLType,  //// LMessages,
  FileUtil,
  Zipper,
{$endif}
  Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,
  StdCtrls, Menus, ExtCtrls, Buttons, ComCtrls,
{$ifndef Darwin}
  MMSystem,
{$endif}
  UnitMidiOpenDialog,
  UnitMessage, UnitMidiPlay, UnitMidiDefinitions, UnitText, UnitXml;

//---------------------------------------------------------------------------
//
// Form for the window (Auto generated by the compiler)
// Additions in the private section
//
//---------------------------------------------------------------------------

type

  { TFormMidiGui }

  TFormMidiGui = class(TForm)
    MenuItemAbout: TMenuItem;
    BevelInside: TBevel;
    BevelOutside: TBevel;
    BitBtnContinue: TBitBtn;
    BitBtnPause: TBitBtn;
    BitBtnPlay: TBitBtn;
    BitBtnSetCycleEndMark: TBitBtn;
    BitBtnSetCycleStartMark: TBitBtn;
    BitBtnStop: TBitBtn;
    CheckBox1: TCheckBox;
    CheckBox10: TCheckBox;
    CheckBox11: TCheckBox;
    CheckBox12: TCheckBox;
    CheckBox13: TCheckBox;
    CheckBox14: TCheckBox;
    CheckBox15: TCheckBox;
    CheckBox16: TCheckBox;
    CheckBox2: TCheckBox;
    CheckBox3: TCheckBox;
    CheckBox4: TCheckBox;
    CheckBox5: TCheckBox;
    CheckBox6: TCheckBox;
    CheckBox7: TCheckBox;
    CheckBox8: TCheckBox;
    CheckBox9: TCheckBox;
    ComboBox1: TComboBox;
    ComboBox10: TComboBox;
    ComboBox11: TComboBox;
    ComboBox12: TComboBox;
    ComboBox13: TComboBox;
    ComboBox14: TComboBox;
    ComboBox15: TComboBox;
    ComboBox16: TComboBox;
    ComboBox2: TComboBox;
    ComboBox3: TComboBox;
    ComboBox4: TComboBox;
    ComboBox5: TComboBox;
    ComboBox6: TComboBox;
    ComboBox7: TComboBox;
    ComboBox8: TComboBox;
    ComboBox9: TComboBox;
    EditTempo: TEdit;
    EditTempoProcent: TEdit;
    EditTranspose: TEdit;
    MenuItemExitAndDeleteOptions: TMenuItem;
    MenuItemExit: TMenuItem;
    MenuFile: TMenuItem;
    MenuHelp: TMenuItem;
    LabelTempo: TLabel;
    LabelTranspose: TLabel;
    MainMenu: TMainMenu;
    MenuItemMidiDeviceSelect: TMenuItem;
    MenuItemMidiSelect4: TMenuItem;
    MenuItemMidiSelect3: TMenuItem;
    MenuItemMidiSelect2: TMenuItem;
    MenuItemMidiSelect1: TMenuItem;
    MenuItemAutoPlay: TMenuItem;
    MenuItemDecoding: TMenuItem;
    MenuItemMidiMixer: TMenuItem;
    MenuItemText: TMenuItem;
    MenuOptions: TMenuItem;
    MenuView: TMenuItem;
    MenuItemOpen: TMenuItem;
    OpenDialog: TOpenDialog;
    ProgressBarMidi: TProgressBar;
    ScrollBar1: TScrollBar;
    ScrollBar10: TScrollBar;
    ScrollBar11: TScrollBar;
    ScrollBar12: TScrollBar;
    ScrollBar13: TScrollBar;
    ScrollBar14: TScrollBar;
    ScrollBar15: TScrollBar;
    ScrollBar16: TScrollBar;
    ScrollBar2: TScrollBar;
    ScrollBar3: TScrollBar;
    ScrollBar4: TScrollBar;
    ScrollBar5: TScrollBar;
    ScrollBar6: TScrollBar;
    ScrollBar7: TScrollBar;
    ScrollBar8: TScrollBar;
    ScrollBar9: TScrollBar;
    StatusBar: TStatusBar;
    Timer: TTimer;
    MenuItemNewOpen: TMenuItem;
    MenuItemSaveMidi: TMenuItem;
    MenuItemSaveText: TMenuItem;
    procedure MenuItemOpenClick(Sender: TObject);
    procedure OnCreate(Sender: TObject);
    procedure OnChange1(Sender: TObject);
    procedure OnChange2(Sender: TObject);
    procedure OnChange3(Sender: TObject);
    procedure OnChange4(Sender: TObject);
    procedure OnChange5(Sender: TObject);
    procedure OnChange7(Sender: TObject);
    procedure OnChange8(Sender: TObject);
    procedure OnChange9(Sender: TObject);
    procedure OnChange10(Sender: TObject);
    procedure OnChange11(Sender: TObject);
    procedure OnChange12(Sender: TObject);
    procedure OnChange13(Sender: TObject);
    procedure OnChange14(Sender: TObject);
    procedure OnChange15(Sender: TObject);
    procedure OnChange16(Sender: TObject);
    procedure MenuItemExitClick(Sender: TObject);
    procedure MenuItemAboutClick(Sender: TObject);
    procedure MenuItemDecodingClick(Sender: TObject);
    procedure EditTransposeChange(Sender: TObject);
    procedure BitBtnPlayClick(Sender: TObject);
{$ifdef FPC}
    procedure OnDropFiles(Sender: TObject; const FileNames: array of String);
{$endif}
    procedure TimerTimer(Sender: TObject);
    procedure MenuViewClick(Sender: TObject);
    procedure BitBtnStopClick(Sender: TObject);
    procedure BitBtnPauseClick(Sender: TObject);
    procedure ComboBox1Change(Sender: TObject);
    procedure ComboBox2Change(Sender: TObject);
    procedure ComboBox3Change(Sender: TObject);
    procedure ComboBox4Change(Sender: TObject);
    procedure ComboBox5Change(Sender: TObject);
    procedure ComboBox6Change(Sender: TObject);
    procedure ComboBox7Change(Sender: TObject);
    procedure ComboBox8Change(Sender: TObject);
    procedure ComboBox9Change(Sender: TObject);
    procedure ComboBox10Change(Sender: TObject);
    procedure ComboBox11Change(Sender: TObject);
    procedure ComboBox12Change(Sender: TObject);
    procedure ComboBox13Change(Sender: TObject);
    procedure ComboBox14Change(Sender: TObject);
    procedure ComboBox15Change(Sender: TObject);
    procedure ComboBox16Change(Sender: TObject);
    procedure BitBtnSetCycleStartMarkClick(Sender: TObject);
    procedure BitBtnSetCycleEndMarkClick(Sender: TObject);
    procedure BitBtnContinueClick(Sender: TObject);
    procedure MenuItemAutoPlayClick(Sender: TObject);
    procedure OnKeyPress(Sender: TObject; var Key: Char);
    procedure OnClose(Sender: TObject; var Action: TCloseAction);
    procedure MenuItemMidiMixerClick(Sender: TObject);
    procedure MenuItemTextClick(Sender: TObject);
    procedure ScrollBar6Change(Sender: TObject);
    procedure MenuItemMidiSelect1Click(Sender: TObject);
    procedure MenuItemMidiSelect2Click(Sender: TObject);
    procedure MenuItemMidiSelect3Click(Sender: TObject);
    procedure MenuItemMidiSelect4Click(Sender: TObject);
    procedure MenuItemExitAndDeleteOptionsClick(Sender: TObject);
    procedure MenuItemNewOpenClick(Sender: TObject);
    procedure MenuItemSaveMidiClick(Sender: TObject);
    procedure OnMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure MenuFileClick(Sender: TObject);
    procedure MenuItemSaveTextClick(Sender: TObject);
  private
    { Private declarations }
{$ifdef Darwin}
    NsOpen: NSOpenPanel;          // The open dialog
{$endif}

    MidiSubState: TMidiSubState;  // Sub state when processing track
    DataMarkIndex: int64;         // Set mark to find Panorama, Tempo etc.
    CurrentCommand: int64;        // If same command -> Use this
    CurrentMetaCommand: int64;        // If same command -> Use this
    CurrentStatusCommand: int64;        // If same command -> Use this
    CurrentChannel: integer;      // Current channel. Numbered 0..15
    CurrentTrack: integer;        // Current track. Numbered 1..64
    SongCaption: string;          // Name of song to be written in the caption
    SongHaveCaption: Boolean;     // When a caption exist - do not write again
    DeltaSum: int64;              // Sum up the delta times (until playing a note)
    MidiAutoStart: boolean;       // Start playing direct when starting
    MidiAutoStop: boolean;        // Close window when finished
    TimeCount: int64;             // Timer for close
{$ifdef FPC}
    UnZipper: TUnZipper;          // Lazarus can do unpack of Zip-file(not used)
{$endif}
    // Array to index above check boxes, combo boxes and scrollbars
    CheckBoxes: array[1..Channels] of TCheckBox;
    ComboBoxes: array[1..Channels] of TComboBox;
    ScrollBars: array[1..Channels] of TScrollBar;
    // More info is in the function code headings
    ChannelCaptionPresent: array[1..Channels] of boolean;
    TrackCaptionPresent: array[1..Tracks] of boolean;
    procedure ReadMidiFile(FileName: string);
    procedure ReadXmlFile(FileName: string);
    function DataRead: byte;
    procedure ReadFile;
    procedure ReadFileMidiTrackHeader;
    procedure ReadFileMidiTrack;
    function ReadBytes(n: integer): int64;
    function ReadVarBytes: int64;
    procedure SetSize;
    procedure Assert(a: boolean; s: string);
    procedure Channel(ch: integer; track: integer; m: string);
    procedure OpenFile(Name: string);
    procedure HandleMetaEvent(Delta: int64;
                             EventMetaCode: int64;
                             EventLength: int64;
                             DataMarkIndex: int64);
    procedure HandleProgramChange(EventCode: int64;
                             DataMarkIndex: int64);
    procedure HandleCommandPanorama(DataMarkIndex: int64);
    procedure HandleNoteOn(DataMarkIndex: int64);
    procedure HandleNoteOff(DataMarkIndex: int64);
    procedure ToEventData(Delta: int64; TextIndex: int64; Command: byte;
                          ControlNumber: byte; ControlValue: byte; Aux: byte);
    function InstrumentString(i: integer): string;
    function MMSysErrorString(i: integer): string;

    procedure Initialisation;
    procedure SaveOptions;
    procedure OpenOptions;
{$ifndef FPC}
    // Only Delphi can handle drop of file into the midi window
    procedure WMDROPFILES(var Message: TWMDROPFILES);
    message WM_DROPFILES;
{$endif}


  public
    { Public declarations }
////    MidiData: TMidiData;
  end;

var FormMidiGui: TFormMidiGui;

implementation

uses UnitMidiIn, UnitMidiMixer, UnitScore;

{$ifdef FPC}
{$R *.lfm}
{$else}
{$R *.DFM}
{$endif}

//---------------------------------------------------------------------------
//
//     Function:      PitchText
//
//     Purpose:       To add a pitch text to the Midi Decode-window
//
//     Parameters:    Note Value = Midi note value
//
//     Returns:       void
//
//     Notes:
//
//---------------------------------------------------------------------------

function PitchText(NoteValue: integer): string;

var r: string;

  begin
    case (NoteValue) mod 12 of
    0: r:='C';
    1: r:='C#/Db';
    2: r:='D';
    3: r:='D#/Eb';
    4: r:='E';
    5: r:='F';
    6: r:='F#/Gb';
    7: r:='G';
    8: r:='G#/Ab';
    9: r:='A';
    10: r:='A#/Bb';
    11: r:='B';
    end;

  PitchText:=r;
  end;


//---------------------------------------------------------------------------
//
//     Function:      HandleMetaEvent
//
//     Purpose:       To handle a single meta event of interest
//
//     Parameters:    EventMetaCode = Event Code (see midi manual)
//                    EventLength   = Length of data following
//                    DataMarkIndex = !!!!
//
//     Returns:       void
//
//     Notes:
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.HandleMetaEvent(Delta: int64; EventMetaCode: int64;
                             EventLength: int64;
                             DataMarkIndex: int64);

var
   i: integer;          // Loop through event data etc.
   m: string;           // Temporary for name of song
   NewTempo: int64;     // Temporary for new tempo value (convert to two bytes)
   s: string;           // For showing data in "MidiIn"-window

  begin
  if EventLength<=$FFFF then
    case EventMetaCode of
    3: // Sequence/Track Name - Instrument name
      begin
      DeltaSum:=DeltaSum+Delta;
      m:='';
      for i:=0 to EventLength-1 do m:=m+chr(MidiData.MidiData[DataMarkIndex+i]);
      if MidiData.MidiTrackHeader.MidiFormat=0 then
        begin
{$ifdef FPC}
{$ifdef DARWIN}
        if not MidiXmlFile then
          begin
          c:='';
          for i:=1 to length(m) do c:=c+CodepageToUtf8(ord(m[i]));
          end;
        Caption:=c;
{$else}
        Caption:=AnsiToUTF8(m);
{$endif}
{$else}
        Caption:=m;
{$endif}
        end
      else
        begin
        if CurrentTrack=1 then
{$ifdef FPC}
{$ifdef Darwin}
          begin
          Caption:=AnsiToUnicodeString(m);
          end;
{$else}
        if not MidiXmlFile then
        Caption:=AnsiToUTF8(m);
{$endif}
{$else}
        Caption:=m;
{$endif}
{$ifdef DelphiXe}
        if MidiXmlFile then m:=UTF8ToAnsi(m);
{$endif}
        MidiData.MidiCurrentTrackName:=m;
        if CurrentChannel>0 then
          begin
          Channel(CurrentChannel,CurrentTrack,MidiData.MidiCurrentTrackName);
          MidiTrackNames[CurrentTrack]:=MidiData.MidiCurrentTrackName;
          MidiChannelMap[CurrentTrack]:=CurrentChannel;
          end;
        end;
      end;
    4: // Instrument Name
      begin
      DeltaSum:=DeltaSum+Delta;
      m:='';
      for i:=0 to EventLength-1 do m:=m+chr(MidiData.MidiData[DataMarkIndex+i]);
      if (CurrentChannel>=0) and (CurrentChannel<Channels) then // Instrument Name
        begin
        if MidiData.MidiTrackHeader.MidiFormat=0 then
          Channel(CurrentChannel,CurrentTrack,m)
        else
          begin
          // Name of the song
          if SongCaption<>'' then
            SongCaption:=SongCaption+' '+m
          else
            SongCaption:=m;
{$ifdef FPC}
          Caption:=AnsiToUTF8(SongCaption);
{$else}
          Caption:=SongCaption;
{$endif}

          SongHaveCaption:=true;
          if CurrentChannel<>0 then Channel(CurrentChannel,CurrentTrack,'');
          end;
        end;
      end;
    5:
      begin  // Text i.e Lyrics for song
      DeltaSum:=DeltaSum+Delta;
      m:='';
      for i:=0 to EventLength-1 do m:=m+chr(MidiData.MidiData[DataMarkIndex+i]);
      MidiTexts[MidiTextIndexIn]:=m;
      MidiTextsTrack[MidiTextIndexIn]:=CurrentTrack-1;
      inc(MidiTextIndexIn);
      MenuItemText.Visible:=true;
      MenuItemSaveText.Visible:=true;
      MidiVisible:=true;
      end;

    6: // Song name for some midi files
      begin
      DeltaSum:=DeltaSum+Delta;
      m:='';
      for i:=0 to EventLength-1 do m:=m+chr(MidiData.MidiData[DataMarkIndex+i]);
{$ifdef FPC}
              Caption:=AnsiToUTF8(m);
{$else}
              Caption:=m;
{$endif}
      end;
    8: // Song name for some midi files
      begin
      DeltaSum:=DeltaSum+Delta;
      m:='';
      for i:=0 to EventLength-1 do m:=m+chr(MidiData.MidiData[DataMarkIndex+i]);
{$ifdef FPC}
{$ifdef Darwin}
      if not MidiXmlFile then m:=AnsiToUnicodeString(m);
      Caption:=m;
{$else}
      if not MidiXmlFile then
        m:=AnsiToUTF8(m);
      Caption:=m;
{$endif}
{$else}
      Caption:=m;
{$endif}
      end;

    $20: // Midi Channel prefix
      begin // Sets current channel (Used when reading instrument name)
      DeltaSum:=DeltaSum+Delta;
      CurrentChannel:=ord(MidiData.MidiData[DataMarkIndex])+1;
      end;
    $54: // Time Signature
      begin
      DeltaSum:=DeltaSum+Delta;
      end;
    $58: // Time Signature
      begin
      DeltaSum:=DeltaSum+Delta;
      MidiTimeSignatureUpper:=MidiData.MidiData[DataMarkIndex];
      MidiTimeSignatureLowerExp:=MidiData.MidiData[DataMarkIndex+1];
      MidiTimeSignatureLower:=PowerOfTwo(MidiTimeSignatureLowerExp);
      MidiTimeSignatureLower:=PowerOfTwo(MidiTimeSignatureLowerExp);
      end;
    $59: // Key Signature
      begin
      DeltaSum:=DeltaSum+Delta;
      MidiKeySignature:=MidiData.MidiData[DataMarkIndex];
      end;

    $07: // Set Measure Number using the event "Cue Point"
      begin
      DeltaSum:=DeltaSum+Delta;
      Assert(EventLength=3,'Channel prefix wrong length');
      MidiData.MidiDataTempoIndex:=DataMarkIndex;
      // The event 0 simulates measure number change. (Changes the measure number,
      // displayed, but generates no event)
      ToEventData(DeltaSum, MidiTextIndexIn,0,SpecialMetaEventMeasure,
                   MidiData.MidiData[DataMarkIndex+1],
                   MidiData.MidiData[DataMarkIndex+2]);
      DeltaSum:=0;
      end;

    $51: // Set Tempo
      begin
      DeltaSum:=DeltaSum+Delta;
      Assert(EventLength=3,'Channel prefix wrong length');
      MidiData.MidiDataTempoIndex:=DataMarkIndex;
      MidiTempo:=ord(MidiData.MidiData[DataMarkIndex]);
      MidiTempo:=(MidiTempo shl 8)+ord(MidiData.MidiData[DataMarkIndex+1]);
      MidiTempo:=(MidiTempo shl 8)+ord(MidiData.MidiData[DataMarkIndex+2]);
      if StringToInt(EditTempoProcent.Text)<10 then EditTempoProcent.Text:='10';
      if StringToInt(EditTempoProcent.Text)>1000 then EditTempoProcent.Text:='1000';
      NewTempo:=(MidiTempo*100) div StrToInt(EditTempoProcent.Text);

      //// What to do? Works with up to 255 tempo changes
      if MidiTempoIndex>MidiTemposMax then
      Assert(MidiTempoIndex<MidiTemposMax,'Too many tempo changes');

////  Use this!!!!   (Don't add tempo change if same as previous)
////      if (MidiTempoIndex=0) or (MidiTempos[MidiTempoIndex-1]<>MidiTempo) then
        begin
      MidiTempos[MidiTempoIndex]:=MidiTempo;
      // The event 0 simulates tempo change. (Changes the timer, but
      // generates no event)
        ToEventData(DeltaSum, MidiTextIndexIn,0,SpecialMetaEventTempo,MidiTempoIndex and 255,0);
      DeltaSum:=0;
        //// Instead: Check if tempo is in list
        if MidiTempoIndex<MidiTemposMax then
      inc(MidiTempoIndex);
        end;

      MidiData.MidiDataSelected[MidiData.MidiDataTempoIndex]:=NewTempo shr 16;
      if MidiData.MidiDataTempoIndex+1<MaxFileSize then
        begin
        MidiData.MidiDataSelected[MidiData.MidiDataTempoIndex+1]:=(NewTempo shr 8) and 255;
        MidiData.MidiDataSelected[MidiData.MidiDataTempoIndex+2]:=NewTempo and 255;
        end
      else
        begin
        if SystemState<>MidiError then
          begin 
          SystemState:=MidiError;
        Messagebox(0,'Index Error','Index outside file size',0);
          halt(1);
          end;
        end;
      end;
    $2F: // End of Track
      begin
      DeltaSum:=0;
      s:='('+IntToHex(MidiData.MidiDataIndex,2)+')Midi Track:';
      MidiData.MidiTrack.MidiTrack:=ReadBytes(4);
      if MidiData.MidiTrack.MidiTrack<>0 then
      MidiData.MidiTrack.MidiTrackLength:=ReadBytes(4);
      s:=s+IntToHex(MidiData.MidiTrack.MidiTrack,4);
      s:=s+' '+IntToHex(MidiData.MidiTrack.MidiTrackLength,4);
      FormMidiIn.MemoMidiIn.Lines.Add(s);
      Assert(CurrentTrack<Tracks,'Midi file has too many tracks('+
                        IntToStr(CurrentTrack)+')');
      if CurrentTrack<Tracks then inc(CurrentTrack);
      MidiData.MidiCurrentTrackName:='';
      CurrentChannel:=-1;
      MidiEventIndexChannelInStart[CurrentTrack]:=
        MidiEventIndexChannelInLast[CurrentTrack-1];
      MidiEventIndexChannelOutStart[CurrentTrack]:=
        MidiEventIndexChannelInLast[CurrentTrack-1];
      MidiEventIndexChannelOutLast[CurrentTrack]:=
        MidiEventIndexChannelInLast[CurrentTrack-1];
      MidiEventIndexChannelInLast[CurrentTrack]:=
        MidiEventIndexChannelInLast[CurrentTrack-1];
      end;
    else
      begin
      DeltaSum:=DeltaSum+Delta;
      end;
    end;
  end;

//---------------------------------------------------------------------------
//
//     Function:       HandleProgramChange
//
//     Purpose:        A handle kommandot Program Change = select instrument
//
//     Parameters:     EventCode      = C0H .. CFH
//                     DataMarkIndex  = Index to the command
//
//     Returns:        void
//
//     Notes:          The command is changed from original to the selected
//                     value from the combobox
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.HandleProgramChange(EventCode: int64;
                             DataMarkIndex: int64);
  begin
  CurrentChannel:=(EventCode and 15)+1;
  //// her kommer man måske med en tosset kanal. -1? 0?
  // With other then original instrument selected
    case ComboBoxes[CurrentChannel].ItemIndex of
    1: // Piano
      begin
      MidiData.MidiDataSelected[DataMarkIndex]:=0;
      MidiDataRhythm[CurrentChannel]:=false;
      end;
    2: // Choirs Aahs
      begin
      MidiData.MidiDataSelected[DataMarkIndex]:=53;
      MidiDataRhythm[CurrentChannel]:=false;
      end;
    3: // Oboe
      Begin
      MidiData.MidiDataSelected[DataMarkIndex]:=41;
      MidiDataRhythm[CurrentChannel]:=false;
      end;
    4: // Violin
      Begin
      MidiData.MidiDataSelected[DataMarkIndex]:=68;
      MidiDataRhythm[CurrentChannel]:=false;
      end;
    5: // Rhythm
      Begin
      MidiData.MidiDataSelected[DataMarkIndex]:=115;
      MidiDataRhythm[CurrentChannel]:=true;
      end;
    end;
  end;

//---------------------------------------------------------------------------
//
//     Function:        HandleCommandPanorama
//
//     Purpose:         The panorama is the position Left-Right. Handle the
//                      command. This command can work in two modes:
//                      Either the scrollbar (i.e. panorama) has been changed
//                      by the user - then the scrollbar determines the panorama
//                      If scrollbar has not been changed then the command
//                      shall be used to set the scrollbar
//
//     Parameters:      EventCode = B0H .. BFH (Command value first byte = 10H)
//                      DataMarkIndex = The position of the panorama value
//
//     Returns:         void
//
//     Notes:
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.HandleCommandPanorama(DataMarkIndex: int64);
  begin
  if (CurrentChannel>0) and (CurrentChannel<=Channels) then
    begin
    ScrollBars[CurrentChannel].Enabled:=true;
    MidiData.MidiDataPanoramaIndex[CurrentChannel]:=DataMarkIndex;
    if MidiData.MidiDataPanoramaUseScrollbar[CurrentChannel] then
      begin
      MidiData.MidiDataSelected[MidiData.MidiDataPanoramaIndex[CurrentChannel]]:=
      ScrollBars[CurrentChannel].Position;
      MidiDataPanorama[CurrentChannel]:=ScrollBars[CurrentChannel].Position;
      end
    else
      ScrollBars[CurrentChannel].Position:=ord(MidiData.MidiData[DataMarkIndex]);
    end
  end;

//---------------------------------------------------------------------------
//
//     Function:          HandleNoteOn
//
//     Purpose:           To play a note
//
//     Parameters:        EventCode = 90H .. 9FH
//
//     Returns:           void
//
//     Notes:             The note is modified with instrument, selected
//                        transposed etc. Note that the note is not played
//                        and not even used for playing. May be used for
//                        saving the midifile
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.HandleNoteOn(DataMarkIndex: int64);
  begin
  Channel(CurrentChannel,CurrentTrack,'');

  // If note shall not be activated the command is changed to Note Off
  // which is 80H instead of 90H etc.
  if not CheckBoxes[CurrentChannel].Checked then
    MidiData.MidiDataSelected[DataMarkIndex-1]:=
      (ord(MidiData.MidiData[DataMarkIndex-1])-$10);
  if MidiDataRhythm[CurrentChannel] then
    begin // Change to rhythm instrument
    MidiData.MidiDataSelected[DataMarkIndex]:=(52);
    end
  else if MidiTranspose<>0 then
    begin // Transpose number of halfsteps
    MidiData.MidiDataSelected[DataMarkIndex]:=
      ((ord(MidiData.MidiData[DataMarkIndex])+MidiTranspose));
    end;
  end;

//---------------------------------------------------------------------------
//
//     Function:          HandleNoteOff
//
//     Purpose:           To stop playing a note
//
//     Parameters:        EventCode = 90H .. 9FH
//
//     Returns:           void
//
//     Notes:             The note is modified with instrument, selected
//                        transposed etc. Note that the note is not played
//                        and not even used for playing. May be used for
//                        saving the midifile
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.HandleNoteOff(DataMarkIndex: int64);

  begin
  if MidiDataRhythm[CurrentChannel] then
    begin
    MidiData.MidiDataSelected[DataMarkIndex]:=(52);
    end
  else if MidiTranspose<>0 then
    begin
    MidiData.MidiDataSelected[DataMarkIndex]:=
      ((ord(MidiData.MidiData[DataMarkIndex])+
           MidiTranspose));
    end;
  end;

//---------------------------------------------------------------------------
//
//     Function:      ToEventData
//
//     Purpose:       To save commands and notes in arrays to be used
//                    when playing
//
//     Parameters:    Both the delta time and the command/noteon/noteoff
//                    is saved
//
//     Returns:       void
//
//     Notes:         Format 0 is saved in one array
//                    Format 1 is saved in 16 arrays, one for each channel
//---------------------------------------------------------------------------

procedure TFormMidiGui.ToEventData(Delta: int64;
                                TextIndex: int64;
                                Command: byte;
                                ControlNumber: byte;
                                ControlValue: byte; Aux: byte);

  begin
  if MidiData.MidiTrackHeader.MidiFormat=0 then
    begin
    MidiEvents[MidiEventIndexIn].Bytes[0]:=Command;
    MidiEvents[MidiEventIndexIn].Bytes[1]:=ControlNumber;
    MidiEvents[MidiEventIndexIn].Bytes[2]:=ControlValue;
    MidiEvents[MidiEventIndexIn].Bytes[3]:=Aux;
    MidiEventDelta[MidiEventIndexIn]:=Delta;
    inc(MidiEventIndexIn);
    end
  else
    begin
    MidiEventsNew[MidiEventIndexChannelInLast[CurrentTrack]].Bytes[0]:=Command;
    MidiEventsNew[MidiEventIndexChannelInLast[CurrentTrack]].Bytes[1]:=ControlNumber;
    MidiEventsNew[MidiEventIndexChannelInLast[CurrentTrack]].Bytes[2]:=ControlValue;
    MidiEventsNew[MidiEventIndexChannelInLast[CurrentTrack]].Bytes[3]:=Aux;
    MidiEventDeltaNew[MidiEventIndexChannelInLast[CurrentTrack]]:=Delta;

    MidiTextsIndex[MidiEventIndexChannelInLast[CurrentTrack]]:=TextIndex;

    inc(MidiEventIndexChannelInLast[CurrentTrack]);
    end;
  end;

//---------------------------------------------------------------------------
//
//     Function:        ReadFileMidiTrack
//
//     Purpose:         Read the track header information
//                      (file is already in memory)
//
//     Parameters:      none
//
//     Returns:         void
//
//     Notes:
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.ReadFileMidiTrack;

var
  EventMetaCode: int64;     // Type of event (Meta code 0 FF)
  EventLength: int64;        // Length of this meta event (next byte after type)
  EventData: int64;          // Some kond of data (temporary)
  ControlNumber: int64;      // When data is the control number
  ControlValue: int64;       // .. and control value
  Delta: int64;              // The time delay before next event (meta or other event)
  s: string;                 // Some string used to get song name or other data
  n: string;                 // The string for debug (decoding)
  m: string;                 // The string for presentation (e.g. song name)
  i: integer;                // For-loop variable (MidiChannelMap)
  j: integer;                // For-loop variable (through message)
  Command: int64;            // Command (after FF or other command)

  begin
  s:='('+IntToHex(MidiData.MidiDataIndex,2)+')Midi Track:';
  MidiData.MidiTrack.MidiTrack:=ReadBytes(4);

  Assert(MidiData.MidiTrack.MidiTrack=$4D54726B,'Track header was not found');

  MidiData.MidiTrack.MidiTrackLength:=ReadBytes(4);
  s:=s+IntToHex(MidiData.MidiTrack.MidiTrack,4);
  s:=s+' '+IntToHex(MidiData.MidiTrack.MidiTrackLength,4);
  FormMidiIn.MemoMidiIn.Lines.Add(s);
  s:='';
  n:='';
  m:='';
  MidiSubState:=MidiSubStart;

  for i:=1 to Tracks do MidiChannelMap[i]:=0;
  for i:=1 to MaxTexts do MidiTextsTrack[i]:=-1;

  while MidiSubState<>MidiSubStop do
    begin
      case MidiSubState of
      MidiSubStart:
        begin
        DataMarkIndex:=MidiData.MidiDataIndex;
        Delta:=ReadVarBytes;
        if (Delta>=Maxint) or (Delta<0) then Delta:=0;
        MidiDeltaTotalIn:=MidiDeltaTotalIn+Delta;
        Command:=ReadBytes(1);
          case Command of
          $FF:
            begin
            s:='('+IntToHex(MidiData.MidiDataIndex,2)+')Meta Event:'+
                               IntToHex(Delta,8) +' '+IntToHex(Command,2)+' ';
            EventMetaCode:=ReadBytes(1);
            EventLength:=ReadVarBytes;
            DataMarkIndex:=MidiData.MidiDataIndex;
            n:='';
            m:='';
            s:=s+IntToHex(EventMetaCode,2);
            s:=s+' '+IntToHex(EventLength,2);
            if EventLength<=$FFFF then
            for j:=1 to EventLength do
              begin
              EventData:=ReadBytes(1);
              s:=s+' '+IntToHex(EventData,2);
              if EventData>32 then n:=n+chr(EventData)
              else n:=n+'.';
              m:=m+chr(EventData);
              end;
            s:=s+' '+n;
            CurrentCommand:=EventMetaCode;
            CurrentMetaCommand:=EventMetaCode;
            HandleMetaEvent(Delta,EventMetaCode,EventLength,DataMarkIndex);
            end;
          $F0:
            begin
            CurrentCommand:=0;
            CurrentStatusCommand:=CurrentCommand;
            DeltaSum:=DeltaSum+Delta;
            s:='('+IntToHex(MidiData.MidiDataIndex,2)+')Meta Event:'+IntToHex(Delta,8) +' '+IntToHex(Command,2)+' ';
            EventMetaCode:=ReadBytes(1);
            EventLength:=ReadVarBytes;
            DataMarkIndex:=MidiData.MidiDataIndex;
            n:='';
            m:='';
            s:=s+IntToHex(EventMetaCode,2);
            s:=s+' '+IntToHex(EventLength,2);
            // This is not how I read the specification, but a compromise
            // that makes the test-midi-files work
            // Read some extra characters until F7
            EventData:=ReadBytes(1);
            while (EventData<>$F7) and (MidiState<>MidiStop) do
              begin
              EventData:=ReadBytes(1);
              s:=s+' '+IntToHex(EventData,2);
              if EventData>32 then n:=n+chr(EventData)
              else n:=n+'.';
              m:=m+chr(EventData);
              end;
            s:=s+' '+n;
            CurrentCommand:=EventMetaCode;
            CurrentStatusCommand:=EventMetaCode;
            end;
          $F7:
            begin
            DeltaSum:=DeltaSum+Delta;
            s:='('+IntToHex(MidiData.MidiDataIndex,2)+')Meta Event:'+IntToHex(Delta,8) +' '+IntToHex(Command,2)+' ';
            EventMetaCode:=ReadBytes(1);
            EventLength:=ReadVarBytes;
            DataMarkIndex:=MidiData.MidiDataIndex;
            n:='';
            m:='';
            s:=s+IntToHex(EventMetaCode,2);
            s:=s+' '+IntToHex(EventLength,2);
            if EventLength<=$FFFF then
            for j:=1 to EventLength do
              begin
              EventData:=ReadBytes(1);
              s:=s+' '+IntToHex(EventData,2);
              if EventData>32 then n:=n+chr(EventData)
              else n:=n+'.';
              m:=m+chr(EventData);
              end;
            s:=s+' '+n;
            CurrentCommand:=EventMetaCode;
            CurrentStatusCommand:=CurrentCommand;
            end;
          $A0..$AF,$E0..$EF,$F2:
            begin // Messages with two data bytes
            DeltaSum:=DeltaSum+Delta;
            CurrentChannel:=(Command and 15)+1;
            if command in [$E0..$EF] then
              s:='('+IntToHex(MidiData.MidiDataIndex,2)+')Pitch Change:'+IntToHex(Delta,8) +' '
            else
            s:='('+IntToHex(MidiData.MidiDataIndex,2)+')Control Change:'+IntToHex(Delta,8) +' ';
            ControlNumber:=ReadBytes(1);
            DataMarkIndex:=MidiData.MidiDataIndex;
            ControlValue:=ReadBytes(1);
            s:=s+IntToHex(Command,2);
            s:=s+' '+IntToHex(ControlNumber,2);
            s:=s+' '+IntToHex(ControlValue,2);

            if command in [$E0..$EF] then
              begin
              s:=s+' ('+FloatToStr(4*(ControlValue*128+ControlNumber-8192)/16384)+')';
////              s:=s+' ('+FloatToStr((4*(ControlValue*128+ControlNumber-8192)/16384)-0.056396484375)+')';
              end;

            CurrentCommand:=Command;
            CurrentStatusCommand:=CurrentCommand;
            if MidiData.MidiTrackHeader.MidiFormat=1 then
              if MidiData.MidiCurrentTrackName='' then
                begin
                Channel(CurrentChannel,CurrentTrack,'')
                end
              else
                begin
                Channel(CurrentChannel,CurrentTrack,MidiData.MidiCurrentTrackName);
                MidiTrackNames[CurrentTrack]:=MidiData.MidiCurrentTrackName;
                MidiChannelMap[CurrentTrack]:=CurrentChannel;
                end;
            ToEventData(DeltaSum,MidiTextIndexIn,Command,ControlNumber,ControlValue,0);
            DeltaSum:=0;
            end;
          $D0..$DF,$F1,$F3:
            begin // Messages with one data byte
            DeltaSum:=DeltaSum+Delta;
            CurrentChannel:=(Command and 15)+1;
            MidiProgramSet[CurrentChannel]:=true;
            s:='('+IntToHex(MidiData.MidiDataIndex,2)+')Program Change:'+IntToHex(Delta,8) +' ';
            DataMarkIndex:=MidiData.MidiDataIndex;
            ControlValue:=ReadBytes(1);
            s:=s+IntToHex(Command,2);
            s:=s+' '+IntToHex(ControlValue,2);
            CurrentCommand:=Command;
            CurrentStatusCommand:=CurrentCommand;
            ToEventData(DeltaSum,MidiTextIndexIn,Command,ControlValue,0,0);
            DeltaSum:=0;
            end;
          $F4..$F6,$F8..$FE:
            begin // Messages with no data bytes
            DeltaSum:=DeltaSum+Delta;
            CurrentChannel:=(Command and 15)+1;
            MidiProgramSet[CurrentChannel]:=true;
            s:='('+IntToHex(MidiData.MidiDataIndex,2)+')Program Change:'+IntToHex(Delta,8) +' ';
            DataMarkIndex:=MidiData.MidiDataIndex;
            s:=s+IntToHex(Command,2);
            CurrentCommand:=Command;
            CurrentStatusCommand:=CurrentCommand;
            ToEventData(DeltaSum,MidiTextIndexIn,Command,0,0,0);
            DeltaSum:=0;
            end;
          $B0..$BF:
            begin
            DeltaSum:=DeltaSum+Delta;
            CurrentChannel:=(Command and 15)+1;
            s:='('+IntToHex(MidiData.MidiDataIndex,2)+')Control Change:'+IntToHex(Delta,8) +' ';
            ControlNumber:=ReadBytes(1);
            DataMarkIndex:=MidiData.MidiDataIndex;
            ControlValue:=ReadBytes(1);
            s:=s+IntToHex(Command,2);
            s:=s+' '+IntToHex(ControlNumber,2);
            s:=s+' '+IntToHex(ControlValue,2);
            CurrentCommand:=Command;
            CurrentStatusCommand:=CurrentCommand;
            if MidiData.MidiTrackHeader.MidiFormat=1 then
              begin
              if MidiData.MidiCurrentTrackName='' then
                Channel(CurrentChannel,CurrentTrack,'')
              else
                Channel(CurrentChannel,CurrentTrack,MidiData.MidiCurrentTrackName);
              end;
            if ControlNumber=10 then
              HandleCommandPanorama(DataMarkIndex);
            ToEventData(DeltaSum,MidiTextIndexIn,Command,ControlNumber,ControlValue,0);
            DeltaSum:=0;
            end;
          $C0..$CF:
            begin
            DeltaSum:=DeltaSum+Delta;
            CurrentChannel:=(Command and 15)+1;
            MidiProgramSet[CurrentChannel]:=true;
            s:='('+IntToHex(MidiData.MidiDataIndex,2)+')Program Change:'+IntToHex(Delta,8) +' ';
            DataMarkIndex:=MidiData.MidiDataIndex;
            ControlValue:=ReadBytes(1);
            s:=s+IntToHex(Command,2);
            s:=s+' '+IntToHex(ControlValue,2);
            CurrentCommand:=Command;
            CurrentStatusCommand:=CurrentCommand;
            HandleProgramChange(Command,DataMarkIndex);
            MidiData.MidiDataProgramSet[CurrentChannel]:=true;
            // We do not know the order of track name and channel number
            // (for format 1). An empty track name says that the channel
            // number came first.
            if MidiData.MidiTrackHeader.MidiFormat=1 then
              begin
              if MidiData.MidiCurrentTrackName<>'' then
              Channel(CurrentChannel,CurrentTrack,MidiData.MidiCurrentTrackName);
              end;
            ToEventData(DeltaSum,MidiTextIndexIn,Command,ControlValue,0,0);
            MidiDataInstrumentOrg[CurrentChannel]:=ControlValue;
            DeltaSum:=0;
            end;
          $90..$9F:
            begin
            DeltaSum:=DeltaSum+Delta;
            CurrentChannel:=(Command and 15)+1;
            s:='('+IntToHex(MidiData.MidiDataIndex,2)+
                ':'+IntToStr(MidiEventIndexIn)+
               ')Note On:'+IntToHex(Delta,8) +' ';
            DataMarkIndex:=MidiData.MidiDataIndex;
            ControlValue:=ReadBytes(2);
            s:=s+IntToHex(Command,2);
            s:=s+' '+IntToHex(ControlValue shr 8,2);
            s:=s+' '+IntToHex(ControlValue and 255,2);
            s:=s+' ('+PitchText(ControlValue shr 8)+')';
            CurrentCommand:=Command;
            CurrentStatusCommand:=CurrentCommand;
            // Ignore too many notes
////            if CurrentTrack<=MidiData.MidiTrackHeader.MidiTracks then
              begin
            HandleNoteOn(DataMarkIndex);
              ToEventData(DeltaSum,MidiTextIndexIn,Command,ControlValue shr 8,ControlValue and $FF,0);
              end;
            DeltaSum:=0;
            end;
          $80..$8F:
            begin
            DeltaSum:=DeltaSum+Delta;
            CurrentChannel:=(Command and 15)+1;
            s:='('+IntToHex(MidiData.MidiDataIndex,2)+')Note Off:'+IntToHex(Delta,8) +' ';
            DataMarkIndex:=MidiData.MidiDataIndex;
            ControlValue:=ReadBytes(2);
            s:=s+IntToHex(Command,2);
            s:=s+' '+IntToHex(ControlValue shr 8,2);
            s:=s+' '+IntToHex(ControlValue and 255,2);
            s:=s+' ('+PitchText(ControlValue shr 8)+')';
            CurrentCommand:=Command;
            CurrentStatusCommand:=CurrentCommand;
            HandleNoteOff(DataMarkIndex);
            ToEventData(DeltaSum,MidiTextIndexIn,Command,ControlValue shr 8,ControlValue and $FF,0);
            DeltaSum:=0;
            end;
          else
            if Command<128 then
              begin
              if (CurrentCommand<>CurrentStatusCommand) then
                begin
                CurrentCommand:=CurrentCommand;
                // Tempo change ($51) is allowed to mix the notes
                //// Hvorfår går det ikke med alle????
               if (Command<$80) and
                  ((CurrentCommand=$51) or (CurrentCommand=$05) or (CurrentCommand=$2F)) and
                  (CurrentStatusCommand in [$80..$9F]) then
                 CurrentCommand:=CurrentStatusCommand;
                end;
              // No new command. Use same command as before
                case CurrentCommand of
                $A0..$AF,$E0..$EF,$F2:
                  begin // Messages with two data bytes
                  if CurrentCommand in [$E0..$EF] then
                    s:='('+IntToHex(MidiData.MidiDataIndex,2)+')Pitch Change:'+IntToHex(Delta,8) +' '
                  else
                  s:='('+IntToHex(MidiData.MidiDataIndex,2)+')Control Change:'+IntToHex(Delta,8) +' ';
                  ControlNumber:=Command;
                  DataMarkIndex:=MidiData.MidiDataIndex;
                  ControlValue:=ReadBytes(1);
                  s:=s+IntToHex(CurrentCommand,2);
                  s:=s+' '+IntToHex(ControlNumber,2);
                  s:=s+' '+IntToHex(ControlValue,2);

                  if CurrentCommand in [$E0..$EF] then
                    begin
                    s:=s+' ('+FloatToStr(4*(ControlValue*128+ControlNumber-8192)/16384)+')';
                    s:=s+' ('+FloatToStr((4*(ControlValue*128+ControlNumber-8192)/16384)-0.056396484375)+')';
                    end;

                  ToEventData(Delta,MidiTextIndexIn,CurrentCommand,ControlNumber,ControlValue,0);
                  end;
                $B0..$BF:
                  begin
                  s:='('+IntToHex(MidiData.MidiDataIndex,2)+')Control Change:'+IntToHex(Delta,8) +' ';
                  ControlNumber:=Command;
                  DataMarkIndex:=MidiData.MidiDataIndex;
                  ControlValue:=ReadBytes(1);
                  s:=s+IntToHex(CurrentCommand,2);
                  s:=s+' '+IntToHex(ControlNumber,2);
                  s:=s+' '+IntToHex(ControlValue,2);
                  if ControlNumber=10 then
                    HandleCommandPanorama(DataMarkIndex);
                  ToEventData(Delta,MidiTextIndexIn,CurrentCommand,ControlNumber,ControlValue,0);
                  end;
                $D0..$DF,$F1,$F3:
                  begin
                  s:='('+IntToHex(MidiData.MidiDataIndex,2)+')Control Change:'+IntToHex(Delta,8) +' ';
                  ControlNumber:=Command;
                  DataMarkIndex:=MidiData.MidiDataIndex;
                  s:=s+IntToHex(CurrentCommand,2);
                  s:=s+' '+IntToHex(ControlNumber,2);
                  ToEventData(Delta,MidiTextIndexIn,CurrentCommand,ControlNumber,0,0);
                  end;
                $C0..$CF:
                  begin
                  s:='('+IntToHex(MidiData.MidiDataIndex,2)+')Control Change:'+IntToHex(Delta,8) +' ';
                  ControlNumber:=Command;
                  DataMarkIndex:=MidiData.MidiDataIndex;
                  s:=s+' '+IntToHex(ControlNumber,2);
                  ToEventData(Delta,MidiTextIndexIn,CurrentCommand,ControlNumber,0,0);
                  MidiDataInstrumentOrg[CurrentChannel]:=ControlNumber;
                  end;
                $90..$9F:
                  begin
                  s:='('+IntToHex(MidiData.MidiDataIndex,2)+
                  ':'+IntToStr(MidiEventIndexIn)+
                  ')Note On:'+IntToHex(Delta,8) +' ';
                  // Note on: The previous byte is the value
                  DataMarkIndex:=MidiData.MidiDataIndex-1;
                  ControlValue:=ReadBytes(1);
                  CurrentChannel:=(CurrentStatusCommand and 15)+1;
                  s:=s+IntToHex(CurrentStatusCommand,2);
                  s:=s+' '+IntToHex(Command,2);
                  s:=s+' '+IntToHex(ControlValue,2);
                  s:=s+' ('+PitchText(ControlValue shr 8)+')';
                  HandleNoteOn(DataMarkIndex);
                  ToEventData(Delta,MidiTextIndexIn,CurrentStatusCommand,Command,ControlValue,0)
                  end;
                $80..$8F:
                  begin
                  s:='('+IntToHex(MidiData.MidiDataIndex,2)+')Note Off:'+IntToHex(Delta,8) +' ';
                  // Note off: The previous byte is the value
                  DataMarkIndex:=MidiData.MidiDataIndex-1;
                  ControlValue:=ReadBytes(1);
                  CurrentChannel:=(CurrentStatusCommand and 15)+1;
                  s:=s+IntToHex(CurrentCommand,2);
                  s:=s+' '+IntToHex(Command,2);
                  s:=s+' '+IntToHex(ControlValue,2);
                  s:=s+' ('+PitchText(ControlValue shr 8)+')';
                  HandleNoteOff(DataMarkIndex);
                  ToEventData(Delta,MidiTextIndexIn,CurrentCommand,command,ControlValue,0);
                  end;
                else if (CurrentCommand=$2F) and (Command=$40) then
                  begin
                  ////ussak--sazsemaisi--aksaksemai----neyzen_aziz_dede.mid
////                  MessageBox(0,'a',PChar(IntToStr(MidiData.MidiDataIndex)),0);
                  end
                else
                  begin
                  s:='An unsupported event was encounted = '+IntToHex(command,1);
                  // Allow some extra zero - but should not be there
                  Assert(command=0,'An unsupported event was encounted = '+IntToHex(command,1));
                  end;
                end;
              end;
          end;
        end;
      end; // case
    FormMidiIn.MemoMidiIn.Lines.Add(s);
    end;
  s:='';
  MidiState:=MidiEnd;
  end;

//---------------------------------------------------------------------------
//
//     Function:            ReadFile
//
//     Purpose:             Read the whole midi file (already in memory)
//
//     Parameters:          none
//
//     Returns:             void
//
//     Notes:               Data will go to the midi arrays
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.ReadFile;

var
  s: string;             // Show the decoded midi data (MidiIn-window)
  c: byte;
  i: integer;
  FileExt: string;
{$ifdef FPC}
  FileMxl: string;
  Info: TSearchRec;
////  RetVal: integer;
{$endif}

  begin
  TextsAreInitialised:=false;
  Errors:=0;
  DeltaSum:=0;
  CurrentChannel:=0;
  CurrentTrack:=1;
  MidiData.MidiDataIndexMax:=0;
  MidiState:=MidiStart;
  FormMidiIn.MemoMidiIn.Clear;
  FormMidiIn.MemoMidiIn.Font.Name:='Courier New';
  FormMidiIn.MemoMidiIn.Font.Size:=8;
  BitBtnPlay.Enabled:=true;
  MenuItemText.Visible:=false;
  MenuItemSaveText.Visible:=false;
  EditTempoProcent.Text:='100';
  EditTranspose.Text:='0';
  MidiPositionForward:=-1;
  MidiPositionForwardNext:=-1;
  MidiPositionChange:=false;

  // Default (4/4) will be changed by Midi FF 58 command
  MidiTimeSignatureUpper:=4;
  MidiTimeSignatureLowerExp:=2;
  MidiTimeSignatureLower:=PowerOfTwo(MidiTimeSignatureLowerExp);

  for i:=1 to Channels do
    begin
    ComboBoxes[i].Clear;
    // Select text is not working properly
    // - but next lines seem to do it
    ComboBoxes[i].Text:='Default';
    ComboBoxes[i].SelLength:=-1;
    ComboBoxes[i].SelText:='Default';
    ComboBoxes[i].Items.Add(LinguaTextOriginal);
    ComboBoxes[i].Items.Add(LinguaTextPiano);      // 1 Piano
    ComboBoxes[i].Items.Add(LinguaTextDoDo);      // 54 Voice Oohs
    ComboBoxes[i].Items.Add(LinguaTextOboe);       // 69 Oboe
    ComboBoxes[i].Items.Add(LinguaTextViolin);     // 41 Violin
    ComboBoxes[i].Items.Add(LinguaTextRhythm);     // 116 Percussion   ////

    ScrollBars[i].Enabled:=false;
    MidiDataComboBoxChanged[i]:=false;
    MidiDataComboBoxChanged[i]:=true;

    MidiDataPanoramaChanged[i]:=false;
    MidiData.MidiDataPanoramaUseScrollbar[i]:=false;
    MidiDataMixer[i]:=64; // Neutral = 100%
    end;

  // Make message about loading
  SystemState:=MidiStarting;

  FileExt:=ExtractFileExt(FileName);
  MidiXmlFile:=false;
  if (FileExt='.xml') or (FileExt='.musicxml') then
    begin
    MidiXmlFile:=true;
    ReadXmlFile(FileName);
    MenuItemSaveMidi.Visible:=true;    //// Error?
    end
  else if FileExt='.mscz' then
    begin
    MidiXmlFile:=true;
    end
  else if FileExt='.mxl' then
    begin
    MidiXmlFile:=true;
{$ifdef FPC}
    UnZipper:=TUnzipper.Create;
      try
        UnZipper.FileName:=Utf8ToAnsi(FileName);
////        UserProfile:=GetEnvironmentVariable('TEMP')+'\'+AnsiToUtf8(FileName);

        UserProfile:=GetEnvironmentVariable('TEMP')+'\'+ExtractFileName(FileName);
        if not DirectoryExists(UserProfile) then
          mkdir(UserProfile);
        UnZipper.OutputPath:=UserProfile;
        UnZipper.Examine;
        UnZipper.UnZipAllFiles;
      finally
        UnZipper.Free;
      end;
    if FindFirst(UserProfile+'\*.xml',faDirectory,Info)=0 then
          FileMxl:=Info.Name;
    ReadXmlFile(AnsiToUtf8(UserProfile+'\'+FileMxl));

{$else}
////    UnzipFile;
{$endif}


{$ifdef TryWinExec}
    retval:=WinExec(PChar('unzip.bat '+FileName+' '+FileName+'.unzipped.xml'),0);
    if retval>32 then
    ReadXmlFile(FileName+'.unzipped.xml')
    else
      begin
      if SystemState<>MidiError then
        begin
        {$ifndef FPC}
        // Also Delphi XE has zip. Add Zip to the "uses"-list
        MessageBox(0,'No unzip program found','Unzipping',MB_APPLMODAL);
        {$endif}
        SystemState:=MidiError;
        end;
      halt(1);
      end;
{$endif}
    end
  else
    begin
    // Demand right extension
    if (LowerCase(ExtractFileExt(FileName))='.mid') or
      (LowerCase(ExtractFileExt(FileName))='.midi') then
      begin
      ReadMidiFile(FileName);
      MenuItemSaveMidi.Visible:=true;
      end
    else
      begin
      MidiState:=MidiStop;
      SystemState:=MidiNoFile;
      FileName:='';
      Assert(true,'File with wrong extention');
    end;
  end;

  if Errors=0 then
    begin
    StatusBar.Panels.Items[3].Text:=ExtractFileName(FileName);
    while MidiState<>MidiStop do
      begin
        case MidiState of
        MidiStart: ReadFileMidiTrackHeader;
        MidiTrackHeader: ReadFileMidiTrack;
        MidiEnd:
          begin
          s:=IntToHex(MidiData.MidiDataIndex,2)+':';
          c:=DataRead;
          s:=s+IntToHex(ord(c),2);
          FormMidiIn.MemoMidiIn.Lines.Add(s);
          s:='';
          end;
        end
      end;
    OpenOptions;
    BitBtnSetCycleStartMark.Enabled:=true;
    BitBtnSetCycleEndMark.Enabled:=true;
    BitBtnContinue.Enabled:=true;
    BitBtnSetCycleStartMark.Visible:=true;
    BitBtnSetCycleEndMark.Visible:=false;
    BitBtnContinue.Visible:=false;
    MidiMixerMustResize:=true;
    if MenuItemAutoPlay.Checked or MidiTest or MidiAutoStop then MidiAutoStart:=true;
    for i:=0 to Channels do MidiClef[i]:=Clef_Undefined ;   // Not set

    MenuitemDecoding.Enabled:=true;
    MenuItemMidiMixer.Enabled:=true;
    MenuItemAutoPlay.Enabled:=true;
    end;
  end;

//---------------------------------------------------------------------------
//
//     Function:        ReadXmlFile
//
//     Purpose:         Read the xml file physically from disk and
//                      convert to Midi while reading
//
//     Parameters:      FileName = the name of the xml file
//
//     Returns:         void
//
//     Notes:           Just call function in UnitXml
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.ReadXmlFile(FileName: string);

  begin
{$ifdef FPC}
{$ifdef Darwin}
  Assert(FileExists(FileName),'MusicXml File not found: '+FileName);
  ReadXmlToMidiFile(FileName,MidiData);
{$else}
  if FileExists(FileName) then
    begin
    ReadXmlToMidiFile(FileName,MidiData);
    end
  else Assert(false,'MusicXml File not found: '+FileName);
{$endif}
{$else}
  Assert(FileExists(FileName),'MusicXml File not found: '+FileName);
  ReadXmlToMidiFile(FileName,MidiData);
{$endif}
  end;

//---------------------------------------------------------------------------
//
//     Function:        ReadMidiFile
//
//     Purpose:         Read the midi file physically from disk
//
//     Parameters:      FileName = the name of the midi file
//
//     Returns:         void
//
//     Notes:           none
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.ReadMidiFile(FileName: string);

var
  c: array[0..256] of byte;
  a: int64;
  MidiIn: THandle;

  begin
  MidiIn:=0;
{$ifdef FPC}
{$ifdef DARWIN}
  if (FileName<>'') and (FileExists(FileName)) then
    MidiIn:=FileOpen(PChar(FileName),fmOpenRead or fmShareDenyNone);
{$else}
  // File names comes different for Windows and DOS
  if (FileName<>'') and (FileExists(FileName)) then
    MidiIn:=FileOpen(PChar(UTF8ToAnsi(FileName)),fmOpenRead or fmShareDenyNone)
  else if (FileName<>'') and (FileExists(FileName)) then
    MidiIn:=FileOpen(PChar(FileName),fmOpenRead or fmShareDenyNone);
{$endif}
{$else}
  if (FileName<>'') and (FileExists(FileName)) then
    MidiIn:=FileOpen(PChar(FileName),fmOpenRead or fmShareDenyNone);
{$endif}


  Assert(MidiIn<>0,'File open error:'+FileName);
  repeat
    a:=FileRead(MidiIn,c,1);
    MidiData.MidiData[MidiData.MidiDataIndexMax]:=c[0];
    MidiData.MidiDataSelected[MidiData.MidiDataIndexMax]:=c[0];
    MidiData.MidiDataChannel[MidiData.MidiDataIndexMax]:=ord('0');

    inc(MidiData.MidiDataIndexMax);

    if not (SystemState=MidiError) then
    if not (MidiData.MidiDataIndexMax<MaxFileSize) then
      begin
      SystemState:=MidiError;
      Assert(MidiData.MidiDataIndexMax<MaxFileSize,'File is too big');
      SaveOptions;
      halt(1);
      end;
    until a<=0;
  FileClose(MidiIn);
  MidiData.MidiDataIndex:=0;
  end;

//---------------------------------------------------------------------------
//
//     Function:          DataRead
//
//     Purpose:           To read one byte from file (already in memory)
//
//     Parameters:        none
//
//     Returns:           The byte read
//
//     Notes:             Before calling this function the file must have
//                        been read by ReadMidiFile or ReadXmlFile or
//                        another new function to handle other formats
//
//---------------------------------------------------------------------------

function TFormMidiGui.DataRead: byte;

  begin
  DataRead:=MidiData.MidiData[MidiData.MidiDataIndex];

  inc(MidiData.MidiDataIndex);
  if MidiData.MidiDataIndex>=MidiData.MidiDataIndexMax then
    begin
    MidiState:=MidiStop;
    MidiSubState:=MidiSubStop;
    end;
  end;

//---------------------------------------------------------------------------
//
//     Function:      ReadBytes
//
//     Purpose:       Read som bytes to build an integer value
//
//     Parameters:    n = Number of bytes
//
//     Returns:       The integer value
//
//     Notes:         none
//
//---------------------------------------------------------------------------

function TFormMidiGui.ReadBytes(n: integer): int64;

var
  v: int64;
  c: byte;
  i: integer;

  begin
  v:=0;
  for i:=1 to n do
    begin
    c:=DataRead;
    v:=(v shl 8)+ord(c)
    end;
  ReadBytes:=v;
  end;

//---------------------------------------------------------------------------
//
//     Function:         ReadVarBytes
//
//     Purpose:
//                       To read a variable number of bytes according
//                       to the midi definition.
//                       (A number greater than 127 continues. Shift the
//                       7 bits in the byte and read next until less 128)
//
//     Parameters:       none
//
//     Returns:          The integer value
//
//     Notes:            For time stamps
//
//---------------------------------------------------------------------------

function TFormMidiGui.ReadVarBytes: int64;

var
  v: int64;  // Building the value
  c: byte;   // Next byte to be considered

  begin
  v:=0;
    repeat
    c:=DataRead;
    v:=(v shl 7)+(ord(c) and 127);
    until (ord(c)<128);
  ReadVarBytes:=v;
  end;

//---------------------------------------------------------------------------
//
//     Function:           Assert
//
//     Purpose:            Write a box at first error
//
//     Parameters:         a = a logical extra shall shall be true to avoid
//                             a message box.
//                         s = a string to be printed if condition is false
//
//     Returns:            void
//
//     Notes:              none
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.Assert(a: boolean; s: string);

  begin
  if not a then
    begin
    SystemState:=MidiError;
    if Errors=0 then
      begin
      inc(Errors);
{$ifdef ZWindows}
      if MessageBox(0,PChar(s),'Assert Failed',MB_OK)=IDOK then
        halt(1);
{$else}
      FormMessage.ErrorMessage('Midi and MusicXml Player Message','Assert Failed: '+s);
{$endif}
      end;
    end;
  end;

//---------------------------------------------------------------------------
//
//     Function:    ReadFileMidiTrackHeader
//
//     Purpose:     Read the track header from midi file already in memory
//
//     Parameters:  none
//
//     Returns:     void
//
//     Notes:       ???? test of header ????
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.ReadFileMidiTrackHeader;

var
  s: string;

  begin
  s:='('+IntToHex(MidiData.MidiDataIndex,2)+')Track Header :';
  MidiData.MidiTrackHeader.MidiTrackHeader:=ReadBytes(4);
  Assert(MidiData.MidiTrackHeader.MidiTrackHeader=$4D546864,
               'Header not found ('+FileName+' is not a correct midi file)');

  MidiData.MidiTrackHeader.MidiTrackHeaderLength:=ReadBytes(4);
  MidiData.MidiTrackHeader.MidiFormat:=ReadBytes(2);
  MidiData.MidiTrackHeader.MidiTracks:=ReadBytes(2);
  MidiData.MidiTrackHeader.MidiTicksPerNote:=ReadBytes(2);

  MidiDivision:=MidiData.MidiTrackHeader.MidiTicksPerNote;

  // Debug to go to the decode window (FormMidiIn)
  s:=s+IntToHex(MidiData.MidiTrackHeader.MidiTrackHeader,4);
  s:=s+' '+IntToHex(MidiData.MidiTrackHeader.MidiTrackHeaderLength,4);
  s:=s+' '+IntToHex(MidiData.MidiTrackHeader.MidiFormat,4);
  s:=s+' '+IntToHex(MidiData.MidiTrackHeader.MidiTracks,4);
  s:=s+' '+IntToHex(MidiData.MidiTrackHeader.MidiTicksPerNote,4);
  FormMidiIn.MemoMidiIn.Lines.Add(s);
  s:='';
  MidiState:=MidiTrackHeader;
  end;


function LimitText(s: string; var ComboBox: TComboBox; TextWidth: integer): string;

var short: boolean;

  begin
  short:=false;
  while (Length(s)>0) and (ComboBox.Canvas.TextExtent(s).cx>=TextWidth) do
    begin
    s:=copy(s,1,Length(s)-1);
    short:=true;
    end;
  if short then s:=s+'...';
  LimitText:=s;
  end;

//---------------------------------------------------------------------------
//
//     Function:        Channel
//
//     Purpose:         To set parameters in order to use this channel
//
//     Parameters:      ch = Channel
//                      m  = Description string for channel (e.g. sopran)
//
//     Returns:         void
//
//     Notes:           Set captions, text and make visible
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.Channel(ch: integer; track: integer; m: string);

var i: integer;

  begin
  Assert((ch>0) and (ch<=Channels),'Illegal Channel Number specified '+
           IntToStr(ch)+' in index:'+IntToHex(MidiData.MidiDataIndex,4));

  if (ch>0) and (ch<=Channels) then
    begin
    if not (SystemState=MidiPlaying) then CheckBoxes[ch].Checked:=true;
    if m<>'' then
      begin
      if ChannelCaptionPresent[ch] then
        begin
        if not TrackCaptionPresent[Track] then
          begin   // We want no dubblets
          if Pos(m,CheckBoxes[ch].Caption)=0 then
          CheckBoxes[ch].Hint:=CheckBoxes[ch].Hint+'/'+m;
{$ifdef FPC $or DelphiXE}
          CheckBoxes[ch].Caption:=LimitText(CheckBoxes[ch].Hint,ComboBoxes[ch],CheckBoxes[ch].Width);
{$else}
          CheckBoxes[ch].Caption:=CheckBoxes[ch].Hint;
{$endif}
          TrackCaptionPresent[track]:=true;
          end
        end
      else
        begin
        CheckBoxes[ch].Hint:=IntToStr(CurrentChannel)+'. '+m;
        CheckBoxes[ch].Caption:=CheckBoxes[ch].Hint;
        TrackCaptionPresent[track]:=true;
        end;
      ChannelCaptionPresent[ch]:=true;
      end;
    CheckBoxes[ch].Visible:=true;
    ComboBoxes[ch].Visible:=true;
    ScrollBars[ch].Visible:=true;
    CheckBoxes[ch].Enabled:=true;
    ComboBoxes[ch].Enabled:=true;

    for i:=1 to ch do
    if CheckBoxes[i].Enabled=false then
      begin
      CheckBoxes[i].Visible:=true;
      ComboBoxes[i].Visible:=true;
      ScrollBars[i].Visible:=true;
      end;
    end;
  end;

//---------------------------------------------------------------------------
//
//     Function:     MixTracks
//
//     Purpose:      For format 1 the tracks are separated
//                   (one whole track, then next etc.)
//                   Mix them to one stream and set apropriate new time
//                   stamp deltas
//
//     Parameters:  none
//
//     Returns:     void
//
//     Notes:       When finding the next event all other events (on other
//                  channels) shall be reduced with the time for the first.
//                  E.g. having two channels, on channel has a note after
//                  one second, the other channel has a note after two seconds,
//                  then we shall play the first note after one second, we
//                  reduce the next event with one second - in order to play
//                  this note one second after the first
//
//---------------------------------------------------------------------------

procedure MixTracks;

var i: integer;             // Loop through tracks
    first: integer;         // The first event (with shortest time)
    min: integer;           // The minimum time value (for the tracks)
    finished: boolean;      // When minimum is found

  begin
  finished:=false;          // Used to find first event.
  MidiDeltaTotalIn:=0;      // Accumulated time for the new mixed deltas
  MidiDeltaTotalOut:=0;     // Nothing is outputted (In this routine)
  MidiEventIndexOut:=0;     // - both time and index to start
  // Events in some tracks?
  while not finished do
    begin
    // Yes, find first event (with the smallest time delta)
    min:=MaxInt;
    first:=0;
    // When no event is found in the tracks, then we are finished
    finished:=true;
    for i:=1 to Tracks do
      begin
      if (MidiEventIndexChannelOutLast[i]-MidiEventIndexChannelOutStart[i]<
        MidiEventIndexChannelInLast[i]-MidiEventIndexChannelInStart[i]) then
        begin
        finished:=false;
        if MidiEventDeltaNew[MidiEventIndexChannelOutLast[i]]<min then
          begin
          min:=MidiEventDeltaNew[MidiEventIndexChannelOutLast[i]];
          first:=i;
          end;
        end;
      end;
    // Reduce channels with time for the smallest time delta
    for i:=1 to Tracks do
      begin
      if (MidiEventIndexChannelOutLast[i]-MidiEventIndexChannelOutStart[i]<
        MidiEventIndexChannelInLast[i]-MidiEventIndexChannelInStart[i]) then
        begin
        MidiEventDeltaNew[MidiEventIndexChannelOutLast[i]]:=
            MidiEventDeltaNew[MidiEventIndexChannelOutLast[i]]-min;
        end;
      end;
    // Put value in the new input buffer and increase index of the channel
    // from which we took the value
    if first<>0 then
      begin
      MidiEvents[MidiEventIndexIn]:=
        MidiEventsNew[MidiEventIndexChannelOutLast[first]];
      MidiEventDelta[MidiEventIndexIn]:=min;
      MidiDeltaTotalIn:=MidiDeltaTotalIn+min;
      MidiTextsIndexNew[MidiEventIndexIn]:=
        MidiTextsIndex[MidiEventIndexChannelOutLast[first]];
      inc(MidiEventIndexChannelOutLast[first]);
      inc(MidiEventIndexIn);
      end;
    end;
  end;

//---------------------------------------------------------------------------
//
//     Function:     OpenFile
//
//     Purpose:      Read a new midi file and do the decoding including
//                   building arrays with events to be used when playing
//
//     Parameters:   Name = name of the midi file
//
//     Returns:      <void>
//
//     Notes:        Either call from Open-menu or started with parameter
//                   as argument of with file name dropped into window.
//                   Calls:
//                   Open Menu: MenuItemOpenClick->OpenFile->ReadFile
//                   Parameter of Dropped: TimerTimer->OpenFile->ReadFile
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.OpenFile(Name: string);

var i: integer;

  begin
  if not FileExists(Name) then
    begin
    MessageBox(0,PChar('File "'+FileName+'" does not exist in directory "'+
        GetCurrentDir+'"'),
       'Midi Error',0);
    end
  else
    begin
    Visible:=false;
    MidiDeltaTotalIn:=0;
    Initialisation;
    for i:=1 to Channels do
      begin
      CheckBoxes[i].Checked:=false;
      CheckBoxes[i].Checked:=false;
      CheckBoxes[i].Caption:='Channel '+IntToStr(i);
      ChannelCaptionPresent[i]:=false;
      CheckBoxes[i].Visible:=false;
      ComboBoxes[i].Visible:=false;
      ComboBoxes[i].ItemIndex:=0;
      ScrollBars[i].Visible:=false;
      CheckBoxes[i].Enabled:=false;
      ComboBoxes[i].Enabled:=false;
      ScrollBars[i].Enabled:=false;
      MidiDataRhythm[i]:=false;
      EditTempo.Text:='100';
      EditTranspose.Text:='0';
      MidiDataComboBoxValue[i]:=0;
      MidiProgramSet[i]:=false;
      end;
    for i:=1 to Tracks do
      begin
      TrackCaptionPresent[i]:=false;
      end;
    {$ifdef FPC}
    {$ifdef Darwin}
    Caption:=FileName;
    {$else}
    Caption:=AnsiToUTF8(FileName);
    {$endif}
    {$else}
    Caption:=FileName;
    {$endif}
    MidiData.MidiTrackHeader.MidiFormat:=0;
    SongHaveCaption:=false;
    SongCaption:='';
    Readfile;
    SetSize;
    Visible:=true;
    MidiVisible:=true;
    MidiData.MidiCurrentTrackName:='';
    if not(MidiData.MidiTrackHeader.MidiFormat=0) then MixTracks;
    if MidiXmlFile then
      StatusBar.Panels.Items[2].Text:='MusicXml '
    else
    StatusBar.Panels.Items[2].Text:='Format '+IntToStr(MidiData.MidiTrackHeader.MidiFormat);
    MidiProgress:=0;
    MidiVisible:=true;
    end;
  end;

//---------------------------------------------------------------------------
//
//     Function:       MenuItemOpenClick
//
//     Purpose:        To set a new file name and open this file
//                     The standard dialog box for that is used
//
//     Parameters:     Windows standard
//
//     Returns:        void
//
//     Notes:          The timer funtion (TimerTimer) and the call back
//                     function will later do the rest
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.MenuItemOpenClick(Sender: TObject);

var
  Home: string;
{$ifndef FPC}
  HomeC: CString;
{$endif}

  begin
{$ifdef FPC}
  Home:=GetEnvironmentVariable('HOME');
{$else}
  GetEnvironmentVariable('HOME',@HomeC,255);
  Home:=PascalString(HomeC);
{$endif}
  OpenDialog.InitialDir:=Home;

{$ifdef FPC}
  OpenDialog.Filter:=
          'Midi, Xml and Mxl Files (*.mid,*.midi,*.xml,*.musicxml,*.mxl)|*.mid;*.midi;*.xml;*.musicxml;*.mxl|'+
          'Midi Files (*.mid,*.midi)|*.mid;*.midi|'+
          'MusicXML Files (*.xml,*.musicxml)|*.xml;*.musicxml|'+
          'Compressed MusicXML files (*.mxl)|*.mxl';
{$else}
  OpenDialog.Filter:=
      'Midi and MusicXML Files (*.mid,*.midi,*.xml,*.musicxml)|*.mid;*.midi;*.xml;*.musicxml|'+
      'Midi Files (*.mid,*.midi)|*.mid;*.midi|'+
      'MusicXML Files (*.xml,*.musicxml)|*.xml;*.musicxml';
{$endif}

  if OpenDialog.Execute then
    begin
    FormMidiIn.MemoMidiIn.Clear;
    FileName:=OpenDialog.FileName;
    FormMessage.Create;
    FormMessage.Visible:=true;
    OpenFile(FileName);
    SystemState:=MidiUp;
    end;
  end;

//---------------------------------------------------------------------------
//
//     Function:       NewOpenClick
//
//     Purpose:        To set a new file name and open this file
//                     The special dialog box for that is used (FormMidiOpenDialog)
//
//     Parameters:     Windows standard
//
//     Returns:        void
//
//     Notes:          The timer funtion (TimerTimer) and the call back
//                     function will later do the rest
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.MenuItemNewOpenClick(Sender: TObject);

var
{$ifndef FPC}
  EnvC: CString;            // Environmentvariable as C string
{$endif}
  Home: string;

  begin
  {$ifdef FPC}
  Home:=GetEnvironmentVariable('HOMEPATH');
{$else}
  GetEnvironmentVariable('HOMEPATH',@EnvC,255);
  Home:=PascalString(EnvC);
{$endif}
  if Pos('users',LowerCase(Home))=0 then
    MenuItemOpenClick(Sender)
  else
    FormMidiOpenDialog.Visible:=true;
  end;

//---------------------------------------------------------------------------
//
//     Function:      Initialisation
//
//     Purpose:       Do the initialisation needed when reading a new midi file
//
//     Parameters:    none
//
//     Returns:       void
//
//     Notes:         Not sure about setting the initial tempo (MidiTempo)
//                    (Most Midi-files have the MetaEvent message defining
//                    the tempo
//
//---------------------------------------------------------------------------


procedure TFormMidiGui.Initialisation;

var i: integer;

  begin
  StatusBar.Panels.Items[0].Text:=LinguaTextStopped;
  SongCaption:='';
  MidiEventIndexIn:=0;
  MidiEventIndexOut:=0;
  MidiTextIndexIn:=1;
  MidiTextIndexOut:=1;
  for i:=0 to MaxEvents do MidiEventDelta[i]:=0;

////  MidiTempo:=500000;
  MidiTempo:=600000;
  // MidiTempos saves tempo information for cycling.
  for i:=1 to MidiTemposMax do MidiTempos[i]:=MidiTempo;
  MidiTempoIndex:=1;
  MidiDivision:=96;
  MidiCycleStartMark:=-1;
  MidiCycleEndMark:=-1;
  // Cycling, the button changes. First time start mark, the end mark
  // and last the continue button is shown
  BitBtnSetCycleStartMark.Visible:=true;
  BitBtnSetCycleEndMark.Visible:=false;
  BitBtnContinue.Visible:=false;
  EditTranspose.Text:='0';
  EditTempo.Text:='100';
  MidiTranspose:=0;
  MidiProgress:=0;
  // MidiFirstNote is used to not make pause before first note
  MidiFirstNote:=true;
  MidiDeltaTotalIn:=0;
  MidiDeltaTotalOut:=0;
  // Cycling - the value -1 indicates not set
  MidiCycleStartMark:=-1;
  MidiCycleStartTime:=-1;
  MidiCycleEndmark:=-1;
  MidiCycleStartTempo:=MidiTempo;

  for i:=1 to Channels do
    begin
    if ComboBoxes[i].ItemIndex>0 then ComboBoxes[i].ItemIndex:=0;
    MidiDataInstrumentOrg[i]:=0;

    MidiEventIndexChannelInStart[i]:=0;
    MidiEventIndexChannelOutStart[i]:=0;
    MidiEventIndexChannelInLast[i]:=0;
    MidiEventIndexChannelOutLast[i]:=0;

    MidiDataRhythm[i]:=false;
    MidiProgramSet[i]:=false;
    MidiDataChecked[i]:=false;
    MidiDataPanorama[i]:=64;

    MidiDataPanoramaChanged[i]:=false;
    MidiDataComboBoxChanged[i]:=false;
    MidiDataComboBoxValue[i]:=(0);
    end;
  BitBtnPlay.Visible:=true;
  BitBtnPause.Visible:=false;
  end;

//---------------------------------------------------------------------------
//
//     Function:    OnCreate
//
//     Purpose:     First initialisation before reading the file
//                  (later comes the procedure Initialisation)
//
//     Parameters:  Windows standard
//
//     Returns:     void
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.OnCreate(Sender: TObject);

var i: integer;
  NumberOfMidiDevices: integer;
  MidiOutNumDevs: integer;
{$ifdef Windows}
  MidiOutCapsData: MidiOutCaps;
{$endif}

{$ifdef FPC}
{$define UseLingua}
{$endif}

{$ifdef UseLingua}
  var Lingua: textfile;
      LinguaLine: string;
      LinguaText: string;
      LinguaPos: integer;
      LinguaResult: string;
      LinguaCaptionResult: string;
{$endif}

  begin
  Caption:='Midi and MusicXml Player';

  MidiSelect:=0;    // MidiDevice selected used sending the Midi event
  MidiSelectNew:=0; // MidiDevice selected when change (Detect in MidiPlay)
{$ifdef Darwin}
  NsOpen:=NsOpenPanel.alloc.init;
{$endif}

{$ifdef FPC}
  if ParamCount>1 then
  StatusBar.Panels.Items[3].Text:=ParamStr(2);
{$endif}
  MidiVisible:=false;
  MidiTest:=false;
  MidiShallClose:=false;
  MidiPositionForward:=-1;
  MidiPositionForwardNext:=-1;
  MidiPositionChange:=false;
{$ifndef FPC}
  Setpriorityclass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
  DragAcceptFiles(FormMidiGui.Handle,true);
{$endif}
  MenuItemText.Visible:=false;
  MenuItemDecoding.Enabled:=false;
  MenuItemMidiMixer.Enabled:=false;
  MenuItemAutoPlay.Enabled:=false;
{$ifdef Darwin}
  MenuItemExit.Visible:=false;
  MenuItemExitAndDeleteOptions.Visible:=false;
{$endif}

  // If program is in start menu then it is installed
/////  MenuItemInstall.Visible:=Pos('program files',LowerCase(Application.ExeName))=0;

  MidiMixerMustResize:=false;
  CheckBoxes[1]:=CheckBox1;
  CheckBoxes[2]:=CheckBox2;
  CheckBoxes[3]:=CheckBox3;
  CheckBoxes[4]:=CheckBox4;
  CheckBoxes[5]:=CheckBox5;
  CheckBoxes[6]:=CheckBox6;
  CheckBoxes[7]:=CheckBox7;
  CheckBoxes[8]:=CheckBox8;
  CheckBoxes[9]:=CheckBox9;
  CheckBoxes[10]:=CheckBox10;
  CheckBoxes[11]:=CheckBox11;
  CheckBoxes[12]:=CheckBox12;
  CheckBoxes[13]:=CheckBox13;
  CheckBoxes[14]:=CheckBox14;
  CheckBoxes[15]:=CheckBox15;
  CheckBoxes[16]:=CheckBox16;

  ComboBoxes[1]:=ComboBox1;
  ComboBoxes[2]:=ComboBox2;
  ComboBoxes[3]:=ComboBox3;
  ComboBoxes[4]:=ComboBox4;
  ComboBoxes[5]:=ComboBox5;
  ComboBoxes[6]:=ComboBox6;
  ComboBoxes[7]:=ComboBox7;
  ComboBoxes[8]:=ComboBox8;
  ComboBoxes[9]:=ComboBox9;
  ComboBoxes[10]:=ComboBox10;
  ComboBoxes[11]:=ComboBox11;
  ComboBoxes[12]:=ComboBox12;
  ComboBoxes[13]:=ComboBox13;
  ComboBoxes[14]:=ComboBox14;
  ComboBoxes[15]:=ComboBox15;
  ComboBoxes[16]:=ComboBox16;

  Scrollbars[1]:=Scrollbar1;
  Scrollbars[2]:=Scrollbar2;
  Scrollbars[3]:=Scrollbar3;
  Scrollbars[4]:=Scrollbar4;
  Scrollbars[5]:=Scrollbar5;
  Scrollbars[6]:=Scrollbar6;
  Scrollbars[7]:=Scrollbar7;
  Scrollbars[8]:=Scrollbar8;
  Scrollbars[9]:=Scrollbar9;
  Scrollbars[10]:=Scrollbar10;
  Scrollbars[11]:=Scrollbar11;
  Scrollbars[12]:=Scrollbar12;
  Scrollbars[13]:=Scrollbar13;
  Scrollbars[14]:=Scrollbar14;
  Scrollbars[15]:=Scrollbar15;
  Scrollbars[16]:=Scrollbar16;

  for i:=1 to Channels do
    begin
{$ifdef FPC}
    CheckBoxes[i].Font.Size:=11;
{$endif}
    ComboBoxes[i].Clear;
    ComboBoxes[i].Text:=LinguaTextOriginal;   // The original may be any(0..127)
    ComboBoxes[i].SelText:=LinguaTextOriginal;   // Handle strange select-problem
    ComboBoxes[i].Items.Add(LinguaTextOriginal); // Select either original or the following
    ComboBoxes[i].Items.Add(LinguaTextPiano);      // 1 Piano
    ComboBoxes[i].Items.Add(LinguaTextDoDo);      // 54 Voice Oohs
    ComboBoxes[i].Items.Add(LinguaTextOboe);       // 69 Oboe
    ComboBoxes[i].Items.Add(LinguaTextViolin);     // 41 Violin
    ComboBoxes[i].Items.Add(LinguaTextRhythm);      // 116 Tom
    MidiDataPanoramaChanged[i]:=false;     // Use original if not changed

    ScrollBars[i].Enabled:=false;
    MidiDataRhythm[i]:=false;      //

    MidiData.MidiDataPanoramaIndex[i]:=64;       //
    // Panarama changed comparared to value from midi file
    // I.e. Use value from the scroll bars
    MidiData.MidiDataPanoramaUseScrollbar[i]:=false;
    // Default track midi volume
    MidiDataMixer[i]:=64;

    end;

  MidiDataMixer[0]:=64; // Set main volume to half level
  FileName:=ParamStr(1);
{$ifdef FPC}
  FileName:=AnsiToUtf8(FileName);
  if (ParamCount>0) and FileExists(ParamStr(1)) then
    begin        ////  !!!!
    StartingWithParam:=true;
    end
  else if (ParamCount>0) and FileExists(ParamStr(1)) then
    begin
    StartingWithParam:=true;
    end;
{$endif}

  if (ParamCount>0) and FileExists(ParamStr(1)) then
    begin
    FileName:=ParamStr(1);
{$ifdef FPC}
    FileName:=AnsiToUtf8(FileName);
{$endif}
    StartingWithParam:=true;
    end
  else if (ParamCount>0) then
    begin
    StartingWithParam:=false;
    end;
  if ParamCount>1 then
    if ParamStr(2)='-T' then MidiTest:=true;
  if ParamCount>1 then
    if ParamStr(2)='-C' then MidiAutoStop:=true;

  BitBtnPlay.Visible:=true;
  BitBtnPause.Visible:=false;
{$ifdef Windows}
{$ifndef FPC}
  BitBtnSetCycleStartMark.Enabled:=false;
{$endif}
{$endif}

{$ifdef Darwin}
  BitBtnSetCycleStartMark.Enabled:=false;
{$endif}
  BitBtnSetCycleEndMark.Enabled:=false;
  BitBtnContinue.Enabled:=false;
  BitBtnSetCycleStartMark.Visible:=true;
  BitBtnSetCycleEndMark.Visible:=false;
  BitBtnContinue.Visible:=false;


{$ifdef Windows}
  // Check the Midi interface
  if not MidiTest then
    begin
    MidiSelectMax:=MidiOutGetNumDevs;
    if MidiSelectMax<1 then
      begin
      MessageBox(0,'There are no Midi devices installed','Midi error',0);
      halt(1);
      end;

    // Default, set midiinterface number to 0 (First selection)
////
    MenuItemMidiDeviceSelect.Visible:=true;
    MenuItemMidiSelect1.Visible:=true;
    MenuItemMidiSelect1.Checked:=true;
  ////  MidiOutGetId(MidiOutHandle[MidiSelect],addr(MidiInterfaceNumber));
    MidiOutGetDevCaps(0,addr(MidiOutCapsData),sizeof(MidiOutCapsData));
    MenuItemMidiSelect1.Caption:=MidiOutCapsData.szPname;

    if MidiSelectMax>1 then
      begin
      MidiOutGetDevCaps(1,addr(MidiOutCapsData),sizeof(MidiOutCapsData));
      MenuItemMidiSelect2.Caption:=MidiOutCapsData.szPname;
      MenuItemMidiSelect2.Visible:=true;
      end
    else
      MenuItemMidiSelect2.Visible:=false;

    if MidiSelectMax>2 then
      begin
      MidiOutGetDevCaps(2,addr(MidiOutCapsData),sizeof(MidiOutCapsData));
      MenuItemMidiSelect3.Caption:=MidiOutCapsData.szPname;
      MenuItemMidiSelect3.Visible:=true;
      end
    else
      MenuItemMidiSelect3.Visible:=false;

    if MidiSelectMax>3 then
      begin
      MidiOutGetDevCaps(3,addr(MidiOutCapsData),sizeof(MidiOutCapsData));
      MenuItemMidiSelect4.Caption:=MidiOutCapsData.szPname;
      MenuItemMidiSelect4.Visible:=true;
      end
    else
      MenuItemMidiSelect4.Visible:=false;

    MidiOutNumDevs:=MidiOutGetNumDevs;

    MidiSelect:=-1;
    for i:=0 to MidiOutNumDevs-1 do
      begin
      MidiOutHandleStatus[i]:=MidiOutOpen(@MidiOutHandle[i],i,0,0,0);
      if MidiSelect<0 then
      if MidiOutHandleStatus[i]=MMSYSERR_NOERROR then
        MidiSelect:=i;
      end;

    MidiSelectNew:=MidiSelect;
 
    if (MidiSelect<0) then
      begin
      SystemState:=MidiError;
      messagebox(0,PChar(MMSysErrorString(MidiOutHandleStatus[0])+
                  '('+IntToStr(MidiOutHandleStatus[0])+')'),
                   'Failed opening midi port',0);
      halt(1);
      end;
    end;

  // Check that at least one midi device is present
  NumberOfMidiDevices:=midiOutGetNumDevs();
  if NumberOfMidiDevices=0 then
    begin
    MessageBox(0,'Midi error','No midi devices are present',0);
    halt(1);
    end;
{$endif}
{$ifdef Windows}

  MidiInNumDevs:=MidiInGetNumDevs;
  if MidiInNumDevs>0 then
    begin
    MidiInOpen(@MidiInHandle,0,DWORD(@MidiInCallBack),0,CALLBACK_FUNCTION);
    MidiInReset(MidiInHandle);
    MidiInAddBuffer(MidiInHandle,@MidiInHeader,SizeOf(MidiInHeader));
    MidiInStart(MidiInHandle);
    end
  else
    begin
    MidiInHandle:=0;
    end;
{$endif}

  if SystemState<>MidiError then SystemState:=MidiStarting;
  MidiState:=MidiStart; //// HER ????
{$ifdef Darwin}
  MidiPlay.Create(false);
{$endif}
{$ifdef UseLingua}
  // A textfile with translations may be added to provide texts in
  // a different language. Must be unicode UTF8. Menu texts and other
  // texts. Only for Lazarus compiler (Which uses UTF8 texts)
  // Every line in the file must have the english text to the left,
  // then a colon and the the translated text.
  if FileExists('Lingua.txt') then
    begin
    AssignFile(Lingua,'Lingua.txt');
    reset(Lingua);
    if not eof(Lingua) then readln(Lingua,LinguaLine);
    LinguaHeader:=LinguaLine;
    while not eof(Lingua) do
      begin
      readln(Lingua,LinguaLine);
      LinguaPos:=Pos('@',LinguaLine);
      LinguaText:=copy(LinguaLine,1,LinguaPos-1);
      LinguaText:=lowercase(LinguaText);
      if LinguaText='file' then
        begin
        LinguaResult:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        MenuFile.Caption:=LinguaResult
        end
      else if LinguaText='open' then
        begin
        LinguaResult:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        MenuItemOpen.Caption:=LinguaResult
        end
      else if LinguaText='save' then
        begin
        LinguaResult:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        MenuItemSaveMidi.Caption:=LinguaResult
        end
      else if LinguaText='exit and delete options' then
        begin
        LinguaResult:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        MenuItemExitAndDeleteOptions.Caption:=LinguaResult
        end
      else if LinguaText='exit' then
        begin
        LinguaResult:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        MenuItemExit.Caption:=LinguaResult
        end
      else if LinguaText='view' then
        begin
        LinguaResult:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        MenuView.Caption:=LinguaResult
        end
      else if LinguaText='decoding' then
        begin
        LinguaResult:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        MenuItemDecoding.Caption:=LinguaResult
        end

      else if LinguaText='text' then
        begin
        LinguaResult:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        MenuItemText.Caption:=LinguaResult
        end
      else if LinguaText='save text' then
        begin
        LinguaResult:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        MenuItemSaveText.Caption:=LinguaResult
        end


      else if LinguaText='mixer' then
        begin
        LinguaResult:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        MenuItemMidiMixer.Caption:=LinguaResult
        end
      else if LinguaText='options' then
        begin
        LinguaResult:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        MenuOptions.Caption:=LinguaResult
        end
      else if LinguaText='auto play' then
        begin
        LinguaResult:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        MenuItemAutoPlay.Caption:=LinguaResult
        end
      else if LinguaText='midi select' then
        begin
        LinguaResult:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        if MenuItemMidiDeviceSelect<>nil then
        MenuItemMidiDeviceSelect.Caption:=LinguaResult
        end
      else if LinguaText='help' then
        begin
        LinguaResult:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        MenuHelp.Caption:=LinguaResult
        end
      else if LinguaText='about' then
        begin
        LinguaResult:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        MenuItemAbout.Caption:=LinguaResult
        end
      else if LinguaText='playing' then
        begin
        LinguaTextPlaying:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextPlaying:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='stopped' then
        begin
        LinguaTextStopped:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextStopped:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='paused' then
        begin
        LinguaTextPaused:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextPaused:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='original' then
        begin
        LinguaTextOriginal:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextOriginal:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='piano' then
        begin
        LinguaTextPiano:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextPiano:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='do do' then
        begin
        LinguaTextDoDo:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextDoDo:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='oboe' then
        begin
        LinguaTextOboe:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextOboe:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='violin' then
        begin
        LinguaTextViolin:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextViolin:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='rhythm' then
        begin
        LinguaTextRhythm:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextRhythm:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='loading' then
        begin
        LinguaTextLoading:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextLoading:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='an unsupported event was encounted' then
        begin
        LinguaTextAnSupportedEventWasEncountered:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextAnSupportedEventWasEncountered:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='does not exist in directory' then
        begin
        LinguaTextDoesNotExistInDirectory:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextDoesNotExistInDirectory:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='play midi and musicxml files' then
        begin
        LinguaTextPlayMidiAndMusicXmlFiles:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextPlayMidiAndMusicXmlFiles:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='there are no midi devices installed' then
        begin
        LinguaTextThereAreNoMidiDevicesInstalled:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextThereAreNoMidiDevicesInstalled:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='no midi devices are present' then
        begin
        LinguaTextNoMidiDevicesArePresent:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextNoMidiDevicesArePresent:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='could not open file' then
        begin
        LinguaTextCouldNotOpenFile:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextCouldNotOpenFile:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='acoustic grand piano' then
        begin
        LinguaTextAcousticGrandPiano:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextAcousticGrandPiano:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='copy midiandmusicxmlplayer.exe returned error code' then
        begin
        LinguaTextCopyReturnedErrorCode:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextCopyReturnedErrorCode:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='restart as administrator to install (right click)' then
        begin
        LinguaTextRestartAsAdministratorToInstall:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextRestartAsAdministratorToInstall:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='error' then
        begin
        LinguaTextError:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextError:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='xml parsing error in line ' then
        begin
        LinguaTextXmlParsingErrorInLine:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextXmlParsingErrorInLine:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText=' - xml parsing error in ' then
        begin
        LinguaTextXmlParsingErrorIn:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextXmlParsingErrorIn:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText=' line ' then
        begin
        LinguaTextXmlLine:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextXmlLine:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='pitch is missing' then
        begin
        LinguaTextPitchIsMissing:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextPitchIsMissing:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='pitch is outside range' then
        begin
        LinguaTextPitchIsOutsideRange:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextPitchIsOutsideRange:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='partnumber is out of range(' then
        begin
        LinguaTextPartNumberIsOutOfRange:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextPartNumberIsOutOfRange:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='too many notes' then
        begin
        LinguaTextTooManyNotes:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextTooManyNotes:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='no xml header found but "' then
        begin
        LinguaTextNoXmlHeaderFoundBut:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextNoXmlHeaderFoundBut:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        end
      else if LinguaText='part number ' then
        begin
        LinguaTextPartNumber:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextPartNumber:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText=' is missing' then
        begin
        LinguaTextIsMissing:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextIsMissing:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='xml error: after <chord/> no pitch nor pause' then
        begin
        LinguaTextXmlErrorAfterChordNoPitchNorPause:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextXmlErrorAfterChordNoPitchNorPause:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='incorrect musicxml file: reading xml file ended in state ' then
        begin
        LinguaTextIncorrectMusicXmlFile:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextIncorrectMusicXmlFile:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='starting' then
        begin
        LinguaTextStarting:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        LinguaTextStarting:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos)
        end
      else if LinguaText='tempo' then
        begin
        LabelTempo.Font.Size:=10;
        LabelTempo.Caption:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        end
      else if LinguaText='transpose' then
        begin
        LabelTranspose.Font.Size:=10;
        LabelTranspose.Caption:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        end
      else if LinguaText='start playing' then
        begin
        BitBtnPlay.Font.Size:=10;
        BitBtnPlay.Hint:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        end
      else if LinguaText='stop playing' then
        begin
        BitBtnStop.Font.Size:=10;
        BitBtnStop.Hint:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        end
      else if LinguaText='press here for start mark of cycle' then
        begin
        BitBtnSetCycleStartMark.Font.Size:=10;
        BitBtnSetCycleStartMark.Hint:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        end
      else if LinguaText='press here for end mark of cycle' then
        begin
        BitBtnSetCycleEndMark.Font.Size:=10;
        BitBtnSetCycleEndMark.Hint:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        end
      else if LinguaText='continue - jump over end mark' then
        begin
        BitBtnContinue.Font.Size:=10;
        BitBtnContinue.Hint:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        end
      else if LinguaText='play midi and musicxml files' then
        begin
        LinguaCaptionResult:=copy(LinguaLine,LinguaPos+1,length(LinguaLine)-LinguaPos);
        end;
      Caption:=LinguaCaptionResult;
      end;
    CloseFile(Lingua);
    end;
{$ifndef DelphiXe}
  CodePage:=GetCodePage;
{$endif}
{$endif}
  end;

//---------------------------------------------------------------------------
//
//     Function:       OnChange1 .. OnChange15
//
//     Purpose:        Buttons for panarama (15 items). Save that a change
//                     has been done
//
//     Parameters:     Windows standard
//
//     Returns:        void
//
//     Notes:          ?? MidiData.MidiDataPanoramaChanged Used?
//
//     Globals:        ????
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.OnChange1(Sender: TObject);

  begin
  if SystemState<>MidiStarting then
    begin
    MidiData.MidiDataPanoramaUseScrollbar[1]:=true;
    MidiDataPanoramaChanged[1]:=true;
    end;
  end;

procedure TFormMidiGui.OnChange2(Sender: TObject);

  begin
  if SystemState<>MidiStarting then
    begin
    MidiData.MidiDataPanoramaUseScrollbar[2]:=true;
    MidiDataPanoramaChanged[2]:=true;
    end;
  end;

procedure TFormMidiGui.OnChange3(Sender: TObject);

  begin
  if SystemState<>MidiStarting then
    begin
    MidiData.MidiDataPanoramaUseScrollbar[3]:=true;
    MidiDataPanoramaChanged[3]:=true;
    end;
  end;

procedure TFormMidiGui.OnChange4(Sender: TObject);

  begin
  if SystemState<>MidiStarting then
    begin
    MidiData.MidiDataPanoramaUseScrollbar[4]:=true;
    MidiDataPanoramaChanged[4]:=true;
    end;
  end;

procedure TFormMidiGui.OnChange5(Sender: TObject);

  begin
  if SystemState<>MidiStarting then
    begin
    MidiData.MidiDataPanoramaUseScrollbar[5]:=true;
    MidiDataPanoramaChanged[5]:=true;
    end;
  end;

procedure TFormMidiGui.ScrollBar6Change(Sender: TObject);

  begin
  if SystemState<>MidiStarting then
    begin
    MidiData.MidiDataPanoramaUseScrollbar[6]:=true;
    MidiDataPanoramaChanged[6]:=true;
    end;
  end;

procedure TFormMidiGui.OnChange7(Sender: TObject);

  begin
  if SystemState<>MidiStarting then
    begin
    MidiData.MidiDataPanoramaUseScrollbar[7]:=true;
    MidiDataPanoramaChanged[7]:=true;
    end;
  end;

procedure TFormMidiGui.OnChange8(Sender: TObject);

  begin
  if SystemState<>MidiStarting then
    begin
    MidiData.MidiDataPanoramaUseScrollbar[8]:=true;
    MidiDataPanoramaChanged[8]:=true;
    end;
  end;

procedure TFormMidiGui.OnChange9(Sender: TObject);

  begin
  if SystemState<>MidiStarting then
    begin
    MidiData.MidiDataPanoramaUseScrollbar[9]:=true;
    MidiDataPanoramaChanged[9]:=true;
    end;
  end;

procedure TFormMidiGui.OnChange10(Sender: TObject);

  begin
  if SystemState<>MidiStarting then
    begin
    MidiData.MidiDataPanoramaUseScrollbar[10]:=true;
    MidiDataPanoramaChanged[10]:=true;
    end;
  end;

procedure TFormMidiGui.OnChange11(Sender: TObject);

  begin
  if SystemState<>MidiStarting then
    begin
    MidiData.MidiDataPanoramaUseScrollbar[11]:=true;
    MidiDataPanoramaChanged[11]:=true;
    end;
  end;

procedure TFormMidiGui.OnChange12(Sender: TObject);

  begin
  if SystemState<>MidiStarting then
    begin
    MidiData.MidiDataPanoramaUseScrollbar[12]:=true;
    MidiDataPanoramaChanged[12]:=true;
    end;
  end;

procedure TFormMidiGui.OnChange13(Sender: TObject);

  begin
  if SystemState<>MidiStarting then
    begin
    MidiData.MidiDataPanoramaUseScrollbar[13]:=true;
    MidiDataPanoramaChanged[13]:=true;
    end;
  end;

procedure TFormMidiGui.OnChange14(Sender: TObject);

  begin
  if SystemState<>MidiStarting then
    begin
    MidiData.MidiDataPanoramaUseScrollbar[14]:=true;
    MidiDataPanoramaChanged[14]:=true;
    end;
  end;

procedure TFormMidiGui.OnChange15(Sender: TObject);

  begin
  if SystemState<>MidiStarting then
    begin
    MidiData.MidiDataPanoramaUseScrollbar[15]:=true;
    MidiDataPanoramaChanged[15]:=true;
    end;
  end;

procedure TFormMidiGui.OnChange16(Sender: TObject);

  begin
  if SystemState<>MidiStarting then
    begin
    MidiData.MidiDataPanoramaUseScrollbar[16]:=true;
    MidiDataPanoramaChanged[16]:=true;
    end;
  end;

procedure TFormMidiGui.MenuItemExitClick(Sender: TObject);

  begin
  halt(0);
  end;

//---------------------------------------------------------------------------
//
//     Function:        AboutClick
//
//     Purpose:         Show an About message with version number
//
//     Parameters:      Windows standard
//
//     Returns:         void
//
//     Notes:           This is the only place for version number
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.MenuItemAboutClick(Sender: TObject);

  begin
{$ifdef Darwin}
  FormMessage.ErrorMessage('Version '+VersionText+
  ' Copyright Magnus Lind (magnus.lind@programfabriken.com)');
{$else}
  MessageBox(0,PChar('Version '+VersionText+
    ' Copyright Magnus Lind(magnus.lind@programfabriken.com) '+
    LinguaHeader),
  'MidiAndMusicXmlPlayer.exe: Play Midi and MusicXml File Selected Tracks',0);
{$endif}
  end;

//---------------------------------------------------------------------------
//
//     Function:          MenuItemDecodingClick
//
//     Purpose:           Show the midi file decoding
//
//     Parameters:        Windows standard
//
//     Returns:           void
//
//     Notes:             none
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.MenuItemDecodingClick(Sender: TObject);

  begin
  MenuItemDecoding.Checked:=not MenuItemDecoding.Checked;
  FormMidiIn.Visible:=MenuItemDecoding.Checked;
  end;

//---------------------------------------------------------------------------
//
//     Function:          MidiStopAllNotes
//
//     Purpose:           For all channels, stop all notes
//                        (No matter playing or not)
//
//     Parameters:        Windows standard
//
//     Returns:           void
//
//     Notes:             none
//
//---------------------------------------------------------------------------

procedure MidiStopAllNotes;

var i,j: integer;
    MidiShortMessage: TMidiShortMessage;
  begin
  for i:=0 to Channels do
  for j:=MidiNoteFirst to MidiNoteLast do
    begin
    MidiShortMessage.Bytes[0]:=($80+i-1);
    MidiShortMessage.Bytes[1]:=(j);
    MidiShortMessage.Bytes[2]:=0;
    MidiShortMessage.Bytes[3]:=0;
    MidiOutMsg(MidiShortMessage.Word);
    end;
  end;



//---------------------------------------------------------------------------
//
//     Function:        EditTransposeChange
//
//     Purpose:         Save the transpose value - number of half tones up
//                      (tranpose down = negative steps)
//
//     Parameters:      Windows standard
//
//     Returns:         void
//
//     Notes:           Reset midi interface to avoid tones that never stop
//                      because a later stop tone (note off) will be another tone
//                      because the notes are transposed.
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.EditTransposeChange(Sender: TObject);

  begin
  MidiTranspose:=StringToInt(EditTranspose.Text);
  if SystemState=MidiPlaying then
  MidiStopAllNotes;
  end;

//---------------------------------------------------------------------------
//
//     Function:           SetSize
//
//     Purpose:            Set the window size and positions of elements
//                         according to the selected mid file. Max 16 channels
//                         are possible but draw only boxes until highest
//                         channel number. Unused channels between will also
//                         be drawn
//
//     Parameters:         none
//
//     Returns:            void
//
//     Notes:              Positions are fixed(according to number of channels)
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.SetSize;

var UnitLength: int64;
    NumberOfBoxes: integer;
    i: integer;
    ClientWidthOrg: integer;

  begin
  UnitLength:=ComboBox1.Height;
  NumberOfBoxes:=4;
  ClientWidthOrg:=ClientWidth;

  for i:=1 to Channels do
    begin
    if CheckBoxes[i].Visible then
      begin
      NumberOfBoxes:=i;
      CheckBoxes[i].Left:=UnitLength;
      CheckBoxes[i].Top:=i*(UnitLength+UnitLength div 4);
      CheckBoxes[i].Width:=(ClientWidthOrg div 3)-UnitLength;
      ComboBoxes[i].Left:=(ClientWidthOrg div 3);
      ComboBoxes[i].Top:=i*(UnitLength+UnitLength div 4);
      ComboBoxes[i].Width:=(ClientWidthOrg div 3)-UnitLength;
      ScrollBars[i].Left:=2*(ClientWidthOrg div 3);
      ScrollBars[i].Top:=i*(UnitLength+UnitLength div 4);
      ScrollBars[i].Width:=(ClientWidthOrg div 3)-UnitLength;
      end;

    // To look good - add 5 to 6 box sizes to height
{$ifdef FPC}
{$ifdef Darwin}
    ClientHeight:=(NumberOfBoxes+5)*(UnitLength+UnitLength div 4)+
                   StatusBar.Height;
{$else}
    ClientHeight:=(NumberOfBoxes+5)*(UnitLength+UnitLength div 4)+
               StatusBar.Height+UnitLength div 2;
{$endif}
{$else}
    ClientHeight:=(NumberOfBoxes+5)*(UnitLength+UnitLength div 4)+
               StatusBar.Height;
{$endif}
    LabelTempo.Top:=(NumberOfBoxes+2)*(UnitLength+UnitLength div 4);
    EditTempoProcent.Top:=LabelTempo.Top+UnitLength;
    EditTempoProcent.Width:=ClientWidthOrg div 8;
    EditTempoProcent.Left:=ClientWidthOrg div 20;
    LabelTempo.Left:=ClientWidthOrg div 20;

    LabelTranspose.Top:=(NumberOfBoxes+2)*(UnitLength+UnitLength div 4);
    EditTranspose.Top:=LabelTempo.Top+UnitLength;
    EditTranspose.Width:=ClientWidthOrg div 8;
    EditTranspose.Left:=ClientWidthOrg div 4;
    LabelTranspose.Left:=ClientWidthOrg div 4;

    BitBtnPlay.Top:=((LabelTempo.Top+EditTempoProcent.Top+EditTempoProcent.Height) div 2)
                    -(BitBtnPlay.Height div 2);
    BitBtnPlay.Left:=ClientWidthOrg-BitBtnPlay.Width-UnitLength div 2;

    BitBtnStop.Top:=BitBtnPlay.Top;
    BitBtnStop.Left:=ClientWidthOrg-2*BitBtnPlay.Width-1*UnitLength;

    BitBtnPause.Top:=((LabelTempo.Top+EditTempoProcent.Top+EditTempoProcent.Height) div 2)
                    -(BitBtnPlay.Height div 2);
    BitBtnPause.Left:=ClientWidthOrg-BitBtnPlay.Width-UnitLength div 2;

    BitBtnSetCycleStartMark.Top:=((LabelTempo.Top+EditTempoProcent.Top+EditTempoProcent.Height) div 2)
                    -(BitBtnPlay.Height div 2);
    BitBtnSetCycleStartMark.Left:=ClientWidthOrg-3*BitBtnPlay.Width-(3*UnitLength) div 2;

    BitBtnSetCycleEndMark.Top:=((LabelTempo.Top+EditTempoProcent.Top+EditTempoProcent.Height) div 2)
                    -(BitBtnPlay.Height div 2);
    BitBtnSetCycleEndMark.Left:=ClientWidthOrg-3*BitBtnPlay.Width-(3*UnitLength) div 2;

    BitBtnContinue.Top:=((LabelTempo.Top+EditTempoProcent.Top+EditTempoProcent.Height) div 2)
                    -(BitBtnPlay.Height div 2);
    BitBtnContinue.Left:=ClientWidthOrg-3*BitBtnPlay.Width-(3*UnitLength) div 2;

    BevelInside.Top:=UnitLength div 2;
    BevelInside.Left:=UnitLength div 2;
    BevelInside.Width:=ClientWidthOrg-UnitLength;
    BevelInside.Height:=(NumberOfBoxes+1)*(UnitLength+UnitLength div 4);

    BevelOutside.Top:=UnitLength div 4;
    BevelOutside.Left:=UnitLength div 4;
    BevelOutside.Width:=ClientWidthOrg-UnitLength div 2;

{$ifdef FPC}
{$ifdef Darwin}
    BevelOutside.Height:=ClientHeight-UnitLength-StatusBar.Height-ProgressBarMidi.Height;
    ProgressBarMidi.Top:=BevelOutside.Top+BevelOutside.Height+
                          (UnitLength div 2);
    ProgressBarMidi.Width:=ClientWidthOrg-UnitLength;
    ProgressBarMidi.Left:=UnitLength div 2;
{$else}
    BevelOutside.Height:=ClientHeight-UnitLength-StatusBar.Height+ProgressBarMidi.Height;
    ProgressBarMidi.Top:=ClientHeight-3*ProgressBarMidi.Height-StatusBar.Height;
    ProgressBarMidi.Width:=ClientWidthOrg-UnitLength;
    ProgressBarMidi.Left:=UnitLength div 2;
{$endif}
{$else}
    BevelOutside.Height:=ClientHeight-UnitLength-StatusBar.Height-ProgressBarMidi.Height;
    ProgressBarMidi.Top:=BevelOutside.Top+BevelOutside.Height+(UnitLength div 2);
    ProgressBarMidi.Width:=ClientWidthOrg-(UnitLength div 2);
    ProgressBarMidi.Left:=UnitLength div 4;

{$endif}

    BevelInside.Visible:=true;
    BevelOutside.Visible:=true;

    // The parts of the scrollbar. Last item takes rest
    StatusBar.Panels.Items[0].Width:=ClientWidthOrg div 5;
    StatusBar.Panels.Items[1].Width:=ClientWidthOrg div 10;
    StatusBar.Panels.Items[2].Width:=ClientWidthOrg div 6;
    StatusBar.Color:=clScrollBar;
    end;
  MidiNumberOfChannels:=NumberOfBoxes;
  end;

//---------------------------------------------------------------------------
//
//     Function:       TimerTimer
//
//     Purpose:        The timer call back function is not part of the
//                     object (The type is predefined in windows)
//                     Therefore some data must be moved to variables
//                     outside the object (public).
//
//     Parameters:     Windows standard
//
//     Returns:        void
//
//     Notes:          Update also status line + caption and handle start up
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.TimerTimer(Sender: TObject);

var i: integer;

  begin
  if SystemState=MidiError then
    Visible:=false
  else
    begin
  if SystemState=MidiStarting then
    begin
    SystemState:=MidiReading;
    FormMidiIn.Caption:=FileName;
{$ifdef FPC}
{$ifdef Darwin}
    if (FileName<>'') and (FileExists(FileName)) then
      begin
      OpenFile(FileName);
      end
    else
      begin
      StatusBar.Panels.Items[0].Text:='Could not open file: '+FileName;
      end;
{$else}
    if (FileName<>'') and (FileExists(FileName)) then
      OpenFile(FileName)
    else if (FileName<>'') and (FileExists(FileName)) then
      OpenFile(AnsiToUtf8(FileName))
    else
      begin
      StatusBar.Panels.Items[0].Text:='Could not open file: '+FileName;
      end;
{$endif}
{$else}
    if (FileName<>'') and (FileExists(FileName)) then
      begin
      OpenFile(FileName);
      end
    else
      begin
      StatusBar.Panels.Items[0].Text:='Could not open file: '+FileName;
      end;
{$endif}
    SystemState:=MidiUp;
    Visible:=true;
    end
  else if SystemState=MidiNoFile then
    begin
    SetSize;
    SystemState:=MidiEmpty;
{$ifndef FPC}
    Visible:=true;
{$endif}
    end;

  if SystemState<>MidiError then
  for i:=1 to Channels do
    begin
    MidiDataChecked[i]:=CheckBoxes[i].Checked;

    if MidiData.MidiDataPanoramaUseScrollbar[i] then
      begin
      if MidiDataPanorama[i]<>ScrollBars[i].Position then
        begin
        MidiDataPanorama[i]:=ScrollBars[i].Position;
        MidiDataPanoramaChanged[i]:=true;
        end;
      end;

      case ComboBoxes[i].ItemIndex of
      0,-1: // Original (-1 = uninitialised)
        begin
        if MidiProgramSet[i] then
          MidiDataComboBoxValue[i]:=MidiDataInstrumentOrg[i]
        else // No instrument setting exist in midifile, use piano
          MidiDataComboBoxValue[i]:=0;
        MidiDataRhythm[i]:=false;
        ComboBoxes[i].Hint:='Original='+InstrumentString(MidiDataInstrumentOrg[i]+1);
        ComboBoxes[i].ShowHint:=true;
        end;
      1: // Piano
        begin
        MidiDataComboBoxValue[i]:=0;
        ComboBoxes[i].ShowHint:=false;
        MidiDataRhythm[i]:=false;
        end;
      2: // Choirs Aahs
        begin
        MidiDataComboBoxValue[i]:=53;
        ComboBoxes[i].ShowHint:=false;
        MidiDataRhythm[i]:=false;
        end;
      3: // Oboe
        Begin
        MidiDataComboBoxValue[i]:=68;
        ComboBoxes[i].ShowHint:=false;
        MidiDataRhythm[i]:=false;
        end;
      4: // Violin
        Begin
        MidiDataComboBoxValue[i]:=41;
        ComboBoxes[i].ShowHint:=false;
        MidiDataRhythm[i]:=false;
        end;
      5: // Rhythm
        Begin
        MidiDataComboBoxValue[i]:=115;
        ComboBoxes[i].ShowHint:=false;
        MidiDataRhythm[i]:=true;
        end;
      else
        begin
        MidiDataRhythm[i]:=false;
        ComboBoxes[i].Hint:='Original='+InstrumentString(MidiDataInstrumentOrg[i]+1);
        ComboBoxes[i].ShowHint:=true;
        end;
      end;
    end;

  MidiTempoProcent:=StringToInt(EditTempoProcent.Text);
  if MidiTempoProcent<10 then MidiTempoProcent:=10;
  if MidiTempoProcent>1000 then MidiTempoProcent:=1000;

  if (MidiEventIndexOut>=MidiEventIndexIn) and (SystemState<>MidiEmpty) then
    begin
    SystemState:=MidiUp;
    StatusBar.Panels.Items[0].Text:=LinguaTextStopped;
    BitBtnPlay.Visible:=true;
    BitBtnPause.Visible:=false;
    MidiProgress:=0;
    MidiTimerRunning:=false;
    if (ParamCount>1) and (ParamStr(2)='-C') then MidiShallClose:=true;
    end;

  if PedalDownChanged then
    begin
    PedalDownChanged:=false;
    if SystemState=MidiPlaying then
      FormMidiGui.BitBtnPauseClick(Sender)
    else
      FormMidiGui.BitBtnPlayClick(Sender);
    end;

  ProgressBarMidi.Position:=MidiProgress;

  if MidiXmlFile then
    StatusBar.Panels.Items[1].Text:=IntToStr(MidiMeasureNumberDisplay)
  else
  StatusBar.Panels.Items[1].Text:=IntToStr(MidiEventIndexOut);
  if MidiAutoStart then
    begin
    BitBtnPlayClick(Sender);
    MidiAutoStart:=false;
    end;
  inc(TimeCount);
  // To finish some tone still playing
  if MidiShallClose then
    begin
    if TimeCount>10 then
      begin
      SaveOptions;
      halt(0);
      end
    end
  else
    TimeCount:=0;
  end;
  MenuItemSaveText.Enabled:=TextsAreInitialised;
  if (FileName<>'') and TextsAreInitialised then
    begin
    MenuItemSaveText.Hint:='Save to '+FileName+'.txt';
    MenuItemSaveMidi.Hint:='Save to '+FileName+'.mid';
    end;
  end;
//---------------------------------------------------------------------------
//
//     Function:          MenuViewClick
//
//     Purpose:           Update the checkmark for showing midi decoding
//
//     Parameters:        Windows standard
//
//     Returns:           void
//
//     Notes:             See the function MenuItemDecodingClick showing
//                        midi data decoding
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.MenuViewClick(Sender: TObject);

  begin
  if not FormMidiIn.Visible then MenuItemDecoding.Checked:=false;
  if not FormMidiMixer.Visible then MenuItemMidiMixer.Checked:=false;
  end;


//---------------------------------------------------------------------------
//
//     Function:       Start playing
//
//     Purpose:        To start playing either from start or paused
//
//     Parameters:     Windows standard
//
//     Returns:        void
//
//     Notes:
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.BitBtnPlayClick(Sender: TObject);

var
  PassedFirstNote: boolean;    // Used to ignore delay before first note
  i: integer;                  // Loop variable to test this

  begin
  if FileName<>'' then
    begin
  PassedFirstNote:=false;
  if SystemState=MidiPaused then
    begin
    // Paused
    SystemState:=MidiPlaying;
    StatusBar.Panels.Items[0].Text:=LinguaTextPlaying;
    BitBtnPlay.Visible:=false;
    BitBtnPause.Visible:=true;
    BitBtnPause.SetFocus;
    end
  else
    begin
    // Stopped, then start
    SystemState:=MidiUp;
    MidiDeltaTotalOut:=0;
    MidiEventIndexOut:=0;
    StatusBar.Panels.Items[0].Text:=LinguaTextPlaying;
    MidiFirstNote:=true;

    BitBtnPlay.Visible:=false;
    BitBtnPause.Visible:=true;
    BitBtnStop.Enabled:=true;
    BitBtnPause.SetFocus;

    MidiDeltaTotalIn:=0;
    for i:=0 to MidiEventIndexIn-1 do
      begin
      if ord(MidiEvents[i].Bytes[0]) in [$90..$9F] then PassedFirstNote:=true;
      if PassedFirstNote then MidiDeltaTotalIn:=MidiDeltaTotalIn+MidiEventDelta[i];
      end;
    end;
    SystemState:=MidiPlaying;
{$ifndef Darwin}
    MidiPlay.Create(false);
{$endif}
  end;
  end;

//---------------------------------------------------------------------------
//
//     Function:       OnDropFiles
//
//     Purpose:        On Lazarus dropped files comes here. Check file
//                     exists and set SystemState. 
//
//     Parameters:     Windows standard
//
//     Returns:        void
//
//     Notes:
//
//---------------------------------------------------------------------------

{$ifdef FPC}
procedure TFormMidiGui.OnDropFiles(Sender: TObject;
  const FileNames: array of String);

var s: string;

  begin
  s:=FileNames[0];
  FileName:=s;
  FormMessage.Visible:=true;
  FormMessage.Create;
  SystemState:=MidiStarting;
  if (High(FileNames)>0) and (not FileExists(FileName) and
     (not FileExists(FileName))) then
    begin
    SystemState:=MidiNoFile;
    Visible:=false;
    end;
  end;

{$endif}

//---------------------------------------------------------------------------
//
//     Function:          BitBtnStopClick
//
//     Purpose:           Stop playing
//
//     Parameters:        Windows standard
//
//     Returns:           void
//
//     Notes:             Resets midi both before and after
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.BitBtnStopClick(Sender: TObject);

  begin
  MidiProgress:=0;
  SystemState:=MidiUp;
  BitBtnPlay.Visible:=true;
  BitBtnPause.Visible:=false;
  MidiEventIndexOut:=0;
  MidiDeltaTotalOut:=0;
  StatusBar.Panels.Items[0].Text:=LinguaTextStopped;
  BitBtnSetCycleStartMark.Visible:=true;
  BitBtnSetCycleEndMark.Visible:=false;
  BitBtnContinue.Visible:=false;
  MidiCycleStartMark:=-1;
  MidiCycleEndMark:=-1;
{$ifndef FPC}
{$ifndef Darwin}
  BitBtnStop.Enabled:=false;
{$endif}
{$endif}
  end;

//---------------------------------------------------------------------------
//
//     Function:     BitBtnPauseClick
//
//     Purpose:      To pause playing until play button is presed
//
//     Parameters:   Windows standard
//
//     Returns:      void
//
//     Notes:        A midi reset stops already playing notes
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.BitBtnPauseClick(Sender: TObject);

  begin
  SystemState:=MidiPaused;
  StatusBar.Panels.Items[0].Text:=LinguaTextPaused;
  BitBtnPlay.Visible:=true;
  BitBtnPlay.SetFocus;
  BitBtnPause.Visible:=false;
  end;

//---------------------------------------------------------------------------
//
//     Function:    ComboBox1Change .. ComboBox15Change
//
//     Purpose:     To select a new instrument - piano, do-do, oboe and rhythm
//
//     Parameters:  Windows standard
//
//     Returns:     void
//
//     Notes:       15 boxes, one per channel
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.ComboBox1Change(Sender: TObject);

  begin
  MidiDataComboBoxChanged[1]:=true;
  end;

procedure TFormMidiGui.ComboBox2Change(Sender: TObject);

  begin
  MidiDataComboBoxChanged[2]:=true;
  end;


procedure TFormMidiGui.ComboBox3Change(Sender: TObject);

  begin
  MidiDataComboBoxChanged[3]:=true;
  end;

procedure TFormMidiGui.ComboBox4Change(Sender: TObject);

  begin
  MidiDataComboBoxChanged[4]:=true;
  end;

procedure TFormMidiGui.ComboBox5Change(Sender: TObject);

  begin
  MidiDataComboBoxChanged[5]:=true;
  end;

procedure TFormMidiGui.ComboBox6Change(Sender: TObject);

  begin
  MidiDataComboBoxChanged[6]:=true;
  end;

procedure TFormMidiGui.ComboBox7Change(Sender: TObject);

  begin
  MidiDataComboBoxChanged[7]:=true;
  end;

procedure TFormMidiGui.ComboBox8Change(Sender: TObject);

  begin
  MidiDataComboBoxChanged[8]:=true;
  end;

procedure TFormMidiGui.ComboBox9Change(Sender: TObject);

  begin
  MidiDataComboBoxChanged[9]:=true;
  end;

procedure TFormMidiGui.ComboBox10Change(Sender: TObject);

  begin
  MidiDataComboBoxChanged[10]:=true;
  end;

procedure TFormMidiGui.ComboBox11Change(Sender: TObject);

  begin
  MidiDataComboBoxChanged[11]:=true;
  end;

procedure TFormMidiGui.ComboBox12Change(Sender: TObject);

  begin
  MidiDataComboBoxChanged[12]:=true;
  end;

procedure TFormMidiGui.ComboBox13Change(Sender: TObject);

  begin
  MidiDataComboBoxChanged[13]:=true;
  end;

procedure TFormMidiGui.ComboBox14Change(Sender: TObject);

  begin
  MidiDataComboBoxChanged[14]:=true;
  end;

procedure TFormMidiGui.ComboBox15Change(Sender: TObject);

  begin
  MidiDataComboBoxChanged[15]:=true;
  end;

procedure TFormMidiGui.ComboBox16Change(Sender: TObject);

  begin
  MidiDataComboBoxChanged[16]:=true;
  end;

//---------------------------------------------------------------------------
//
//     Function: BitBtnSetCycleStartMarkClick
//
//     Purpose:  When cycling some part of the melody, set a mark where
//               the looping part starts
//
//     Parameters: Sender = Windows standard
//
//     Returns:    void
//
//     Notes:      None
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.BitBtnSetCycleStartMarkClick(Sender: TObject);

  begin
  BitBtnSetCycleStartMark.Visible:=false;
  BitBtnSetCycleEndMark.Visible:=true;
  BitBtnContinue.Visible:=false;
  MidiCycleStartMark:=MidiEventIndexOut;
  MidiCycleStartTime:=MidiDeltaTotalOut;
  MidiCycleStartTempo:=MidiTempo;
  MidiCycleEndMark:=-1;
  end;

//---------------------------------------------------------------------------
//
//     Function: BitBtnSetCycleEndMarkClick
//
//     Purpose:  When cycling some part of the melody, set a mark where
//               the melody shall loop and jump back
//
//     Parameters: Sender = Windows standard
//
//     Returns:    void
//
//     Notes:      None
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.BitBtnSetCycleEndMarkClick(Sender: TObject);

  begin
  MidiStopAllNotes; //// ????
  BitBtnSetCycleStartMark.Visible:=false;
  BitBtnSetCycleEndMark.Visible:=false;
  BitBtnContinue.Visible:=true;
  MidiCycleEndMark:=MidiEventIndexOut;
  MidiEventIndexOut:=MidiCycleStartMark;
  MidiDeltaTotalOut:=MidiCycleStartTime;
  MidiTempo:=MidiCycleStartTempo;


  if SystemState=MidiUp then
    begin
    MidiCycleStartTime:=0;
    MidiCycleEndMark:=MidiEventIndexIn-1;
    MidiCycleStartMark:=1;
    MidiEventIndexOut:=MidiCycleStartMark;
    MidiDeltaTotalOut:=MidiCycleStartTime;
    end;
  end;

//---------------------------------------------------------------------------
//
//     Function: BitBtnContinueClick
//
//     Purpose:  After melody is paused, restart playing
//
//     Parameters: Sender = Windows standard
//
//     Returns:    void
//
//     Notes:      None
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.BitBtnContinueClick(Sender: TObject);

  begin
  BitBtnSetCycleStartMark.Visible:=true;
  BitBtnSetCycleEndMark.Visible:=false;
  BitBtnContinue.Visible:=false;
  MidiCycleStartMark:=-1;
  MidiCycleEndMark:=-1;
  end;

//---------------------------------------------------------------------------
//
//     Function: MenuItemAutoPlayClick
//
//     Purpose:  To set the option that the melody shall start playing
//               when opening the program
//
//     Parameters: Sender = Windows standard
//
//     Returns:    void
//
//     Notes:      None
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.MenuItemAutoPlayClick(Sender: TObject);

  begin
  MenuItemAutoPlay.Checked:=not MenuItemAutoPlay.Checked;
  end;

//---------------------------------------------------------------------------
//
//     Function: BoolToInt
//
//     Purpose:  Convert 1=true, 0=false (Used when writing the option file)
//
//     Parameters: b = true or false
//
//     Returns:    1 for true, 0 for false
//
//     Notes:      None
//
//---------------------------------------------------------------------------

function BoolToInt(b: boolean): integer;

  begin
  if b then BoolToInt:=1 else BoolToInt:=0;
  end;

//---------------------------------------------------------------------------
//
//     Function: IntToBool
//
//     Purpose:  Convert 1=true, 0=false (Used when reading the option file)
//
//     Parameters: i =  0..1
//
//     Returns:    true for 1, false for 0
//
//     Notes:      None
//
//---------------------------------------------------------------------------

function IntToBool(i: integer): boolean;

  begin
  if i<>0 then IntToBool:=true else IntToBool:=false;
  end;

//---------------------------------------------------------------------------
//
//     Function: GetUserProfile
//
//     Purpose:  Get the user profile directory(to save options there)
//
//     Parameters: <none>
//
//     Returns:    a string containing the directory
//
//     Notes:      None
//
//---------------------------------------------------------------------------

function GetUserProfile: string;

var UserProfile: string;
    UserDir: string;
{$ifndef FPC}
    EnvC: CString;            // Environmentvariable as C string
{$endif}

  begin
{$ifdef FPC}
{$ifdef Darwin}
  // MAC  Lazarus
  UserDir:=GetEnvironmentVariable('HOME');
  UserProfile:=UserDir+'/MidiOptions';
  if not DirectoryExists(UserProfile) then MkDir(UserProfile);
  UserProfile:=UserProfile+'/'+ExtractFileName(FileName)+'.options';
{$else}
  // PC Lazarus
  UserDir:=GetEnvironmentVariable('USERPROFILE');
  UserProfile:=UserDir+'\MidiOptions';
  if not DirectoryExists(UserProfile) then MkDir(UserProfile);
  UserProfile:=UserProfile+'\'+ExtractFileName(FileName)+'.options';
{$endif}
{$else}
  // PC Delphi
  GetEnvironmentVariable('USERPROFILE',@EnvC,255);
  UserDir:=PascalString(EnvC);
  UserProfile:=UserDir+'\MidiOptions';
  if not DirectoryExists(UserProfile) then MkDir(UserProfile);
  UserProfile:=UserProfile+'\'+ExtractFileName(FileName)+'.options';
{$endif}
  GetUserProfile:=UserProfile;
  end;

//---------------------------------------------------------------------------
//
//     Function: OpenOptions
//
//     Purpose:  Read the options for the specified melody
//
//     Parameters: None
//
//     Returns:    void
//
//     Notes:      None
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.OpenOptions;

var Options: textfile;        // Option file is placed in "USERPROFILE"
    UserProfileTest: string;  // User profile used for test
////    CurrentDirectory: string; // Current Directory
    OptionValues: array[1..NumberOfOptions] of integer; // The options
    MonitorCount: integer;    // When placing windows, there may be more screens
    IsInside: boolean;        // Check that window is inside screen
    i: integer;               // Index to profile data

  begin
  for i:=1 to NumberOfOptions do OptionValues[i]:=0;
  UserProfile:=GetUserProfile;

  // Testing must use same profile options as the org files
////  CurrentDirectory:=GetCurrentDir;
  UserProfileTest:=ExtractFileName(FileName)+'.options';
  if MidiTest then
    begin
    if FileExists(UserProfileTest) then
      UserProfile:=UserProfileTest
{$ifdef FPC}
    else if FileExists(UserProfileTest) then
        UserProfile:=Utf8ToAnsi(UserProfileTest)
    else if FileExists(AnsiToUtf8(UserProfileTest)) then
        UserProfile:=AnsiToUtf8(UserProfileTest)
    else if FileExists(Utf8ToAnsi(UserProfileTest)) then
        UserProfile:=Utf8ToAnsi(UserProfileTest)

{$endif}
    else
      begin
      if FileExists(UserProfile) then
        begin
{$ifdef FPC}
{$ifdef Darwin}
        CopyFile(PChar(UserProfile),PChar(AnsiToUtf8(UserProfileTest)),false);
{$else}
        CopyFile(PChar(AnsiToUtf8(UserProfile)),PChar(AnsiToUtf8(UserProfileTest)),false);
{$endif}
{$else}
        CopyFile(PChar(UserProfile),PChar(UserProfileTest),false);
{$endif}
        end;
      end;
    end;

  MonitorCount:=Screen.MonitorCount;   ////       TEST MED EKSTRA SKÆRM
////  Left:=Screen.Monitors[0].Left;

  //// Too early - the height is modified later.
{$ifdef FPC}
  if not FileExists(UserProfile) then
{$else}
  if not FileExists(UserProfile) then
{$endif}
    begin
    Left:=(Screen.Width-Width) div 2;
    Top:=(Screen.Height-Height) div 2;
    end;

{$ifdef FPC}
  if FileExists(UserProfile) then
{$else}
  if FileExists(UserProfile) then
{$endif}

    begin
    AssignFile(options,UserProfile);
    reset(options);

    for i:=1 to NumberOfOptions do
      begin
      if not eof(options) then
      readln(options,OptionValues[i]);
      end;
    // A magic number is put into the saved configuration data to check
    // it is OK. Both in start and end
    if (OptionValues[1]=OptionsMagicNumber) and
       (OptionValues[NumberOfOptions]=OptionsMagicNumber) then
      begin
      // Checkboxes for each channel
      for i:=1 to 16 do CheckBoxes[i].Checked:=IntToBool(OptionValues[i+1]);
      // Instrument selection in Combo Boxes
      for i:=1 to 16 do
        begin
        ////
        if (OptionValues[i+17]>=0) and (OptionValues[i+17]<5) then      //// Definition
        ComboBoxes[i].SelStart:=Length(SelectableInstruments[OptionValues[i+17]]);
        ComboBoxes[i].SelLength:=0;
        ComboBoxes[i].SelText:='';
        ComboBoxes[i].SelStart:=-1;
        if OptionValues[i+17]>=0 then
          ComboBoxes[i].ItemIndex:=OptionValues[i+17]   //// Definitions !!!!
        else
          ComboBoxes[i].ItemIndex:=0;   //// Definitions !!!!
        // This removes any selection
{$ifdef Windows}
{$ifdef FPC}
        PostMessage(ComboBoxes[i].Handle,CB_SETEDITSEL,-1,0);
{$endif}
{$endif}

        end;
      // Panorama values to scrollbars
      for i:=1 to 16 do
        begin
        if OptionValues[i+33]>=0 then
          begin
          ScrollBars[i].Position:=OptionValues[i+33];
          MidiData.MidiDataPanoramaUseScrollbar[i]:=true;
          MidiDataPanoramaChanged[i]:=true;
          end;
        end;
      // Mixer values
      for i:=0 to 16 do MidiDataMixer[i]:=OptionValues[i+50];
      // Some single values - Auto
      MenuItemAutoPlay.Checked:=IntToBool(OptionValues[67]);
      // Midi Output Device select. If OK then set value
      if (OptionValues[68]>=0) and (OptionValues[68]<MidiSelectMax) then
      if MidiOutHandleStatus[OptionValues[68]]=MMSYSERR_NOERROR then
        begin
        MidiSelect:=OptionValues[68];
        MidiSelectNew:=MidiSelect;
        MenuItemMidiSelect1.Checked:=MidiSelect=0;
        MenuItemMidiSelect2.Checked:=MidiSelect=1;
        MenuItemMidiSelect3.Checked:=MidiSelect=2;
        MenuItemMidiSelect4.Checked:=MidiSelect=3;
        end;

      // Procent (Set tempo)
      EditTempoProcent.Text:=IntToStr(OptionValues[69]);
      // Transpose value (Note half steps)
      EditTranspose.Text:=IntToStr(OptionValues[70]);
      // Position of the window
      if StartingWithParam then
        begin
        // Set position only for newly started program. If already started
        // use current position.
      Left:=OptionValues[71];        //// Definitions !!!!
      Top:=OptionValues[72];
        StartingWithParam:=false;
        end;
      //// Two values for mixer position OptionValues[73] OptionValues[74]
      // FATTTAS ELLER????
      Color:=$CF;
      end;
    CloseFile(options);
    end;
  // Check that window has part inside screen
  IsInside:=false;
  MonitorCount:=Screen.MonitorCount;
  for i:=0 to MonitorCount-1 do
    begin
    if (Left>=Screen.Monitors[i].Left) and
       (Left<Screen.Monitors[i].Left+((9*Screen.Monitors[i].Width) div 10)) and
       (Top>=Screen.Monitors[i].Top) and
       (Top<Screen.Monitors[i].Top+((9*Screen.Monitors[i].Height) div 10)) then
    IsInside:=true;
    end;

  // If not inside then put it near top-left
  if not IsInside then
    begin
    Left:=Screen.Monitors[0].Width div 20;
    Top:=Screen.Monitors[0].Width div 20;
    end;
  end;

//---------------------------------------------------------------------------
//
//     Function: SaveOptions
//
//     Purpose:  Write the options for the specified melody to option file
//
//     Parameters: None
//
//     Returns:    void
//
//     Notes:      None
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.SaveOptions;

var options: textfile;
    i: integer;
    ErrorCode: integer;

  begin
{$I-}

{$ifdef FPC}
{$ifndef Darwin}
  UserProfile:=Utf8ToAnsi(UserProfile);
{$endif}
{$endif}
  if FileExists(UserProfile) then DeleteFile(UserProfile);
  AssignFile(options,UserProfile);
  ErrorCode:=IORESULT;
  if ErrorCode<>0 then
    begin
    Assert(false,'IO-error: '+IntToStr(ErrorCode)+' in '+UserProfile);
    end
  else
    begin
  rewrite(options);
    end;

  ErrorCode:=IORESULT;
  if ErrorCode=0 then
    begin
    writeln(options,OptionsMagicNumber);
    for i:=1 to 16 do writeln(options,BoolToInt(MidiDataChecked[i]));
    for i:=1 to 16 do writeln(options,ComboBoxes[i].ItemIndex);
    for i:=1 to 16 do writeln(options,ScrollBars[i].Position);
    for i:=0 to 16 do writeln(options,ord(MidiDataMixer[i]));
    writeln(options,BoolToInt(MenuItemAutoPlay.Checked));
    writeln(options,MidiSelectNew);  // Midi-device selection
    writeln(options,MidiTempoProcent);
    writeln(options,MidiTranspose);
    writeln(options,Left);
    writeln(options,Top);
    writeln(options,0);              // Mixer position X
    writeln(options,0);              // Mixer position Y
    writeln(options,OptionsMagicNumber);         // Magic number fotr check
    CloseFile(options);
    end;
  {$I+}
  end;

//---------------------------------------------------------------------------
//
//     Function:   OnKeyPress
//
//     Purpose:    Hot keys:
//                 "t" = Show text window
//                 "d" = Show midi decoded
//                 "m" = Show Mixer
//                 "s" = Show score
//                 Esc = Stop and terminate midi program
//
//     Parameters: Sender = Windows standard
//                 Key    = The pressed key
//
//     Returns:    void
//
//     Notes:      None
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.OnKeyPress(Sender: TObject; var Key: char);

  begin // Note: these do not work on MAC
  if not MidiTest then
    begin
    if (Key='T') or (Key='t') then MenuItemTextClick(Sender); // Show text
    if (Key='D') or (Key='d') then MenuItemDecodingClick(Sender); // Show decoding
    if (Key='M') or (Key='m') then MenuItemMidiMixerClick(Sender); // Show mixer
    if (Key='S') or (Key='s') then FormScore.Visible:=true; // Secret button for test
    if (Key='O') or (Key='o') then FormMidiOpenDialog.Visible:=true; // Open file
    if (Key=chr(ord('O') and 31)) then MenuItemOpenClick(Sender); // Also open file
    if Key=chr(27) then
      begin // Escape - terminate program
      SaveOptions;
      halt(0);
      end;
    end;
  end;

//---------------------------------------------------------------------------
//
//     Function:   OnClose
//
//     Purpose:    To close (terminate) midi. Save options and stop
//
//     Parameters: Sender = Windows standard
//                 Action = Window standard
//
//     Returns:    void
//
//     Notes:      Comes here when clicking X in upper right corner of window
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.OnClose(Sender: TObject; var Action: TCloseAction);

  begin
  MidiStopAllNotes;
  SaveOptions;
  halt(0);
  end;

//---------------------------------------------------------------------------
//
//     Function:   MenuItemMidiMixerClick
//
//     Purpose:    To open a mixer window (called when selecting menu item)
//
//     Parameters: Sender = Windows standard
//                 Action = Window standard
//
//     Returns:    void
//
//     Notes:      Comes here when clicking X in upper right corner of window
//
//---------------------------------------------------------------------------
procedure TFormMidiGui.MenuItemMidiMixerClick(Sender: TObject);

  begin
  if FormMidiMixer.Visible then
    begin
    MenuItemMidiMixer.Checked:=false;
    FormMidiMixer.Visible:=false;
    end
  else
    begin
    MenuItemMidiMixer.Checked:=true;
    FormMidiMixer.Visible:=true;
    end;
  end;

procedure TFormMidiGui.MenuItemMidiSelect1Click(Sender: TObject);

  begin
  MidiSelectNew:=0;
  MenuItemMidiSelect1.Checked:=true;
  MenuItemMidiSelect2.Checked:=false;
  MenuItemMidiSelect3.Checked:=false;
  MenuItemMidiSelect4.Checked:=false;
  end;

procedure TFormMidiGui.MenuItemMidiSelect2Click(Sender: TObject);

  begin
  MidiSelectNew:=1;
  MenuItemMidiSelect1.Checked:=false;
  MenuItemMidiSelect2.Checked:=true;
  MenuItemMidiSelect3.Checked:=false;
  MenuItemMidiSelect4.Checked:=false;
  end;

procedure TFormMidiGui.MenuItemMidiSelect3Click(Sender: TObject);

  begin
  MidiSelectNew:=2;
  MenuItemMidiSelect1.Checked:=false;
  MenuItemMidiSelect2.Checked:=false;
  MenuItemMidiSelect3.Checked:=true;
  MenuItemMidiSelect4.Checked:=false;
  end;

procedure TFormMidiGui.MenuItemMidiSelect4Click(Sender: TObject);

  begin
  MidiSelectNew:=3;
  MenuItemMidiSelect1.Checked:=false;
  MenuItemMidiSelect2.Checked:=false;
  MenuItemMidiSelect3.Checked:=false;
  MenuItemMidiSelect4.Checked:=true;
  end;

//---------------------------------------------------------------------------
//
//     Function:   WMDROPFILES
//
//     Purpose:    Drag and drop -
//                 Open a midi file by dragging and dropping it in the
//                 midi window
//
//     Parameters: Message = a Window-message containing file name etc.
//
//     Returns:    void
//
//     Notes:      Does no work in Lazarus (Free Pascal Compiler)
//
//---------------------------------------------------------------------------
{$ifndef FPC}
procedure TFormMidiGui.WMDROPFILES(var Message: TWMDROPFILES);
var
  NumFiles: longint;
  buffer: array[0..255] of char;

  begin
  NumFiles:=DragQueryFile(message.Drop,4294967295,nil,0);
  if NumFiles=1 then
    begin
    DragQueryFile(message.Drop,0,@buffer,sizeof(buffer));
    FileName:=Strpas(buffer);
    StatusBar.Panels.Items[0].Text:=FileName;
    FormMessage.Visible:=true;
    FormMessage.Create;
    OpenFile(FileName);
    SystemState:=MidiUp;
    end;
  end;
{$endif}

//---------------------------------------------------------------------------
//
//     Function:   InstrumentString
//
//     Purpose:    To produce a text description for each instrument
//
//     Parameters: i = Instrument number
//
//     Returns:    a description text for the instrument
//
//     Notes:      None
//
//---------------------------------------------------------------------------

function TFormMidiGui.InstrumentString(i: integer): string;

  begin  //// Banks?
    case i of
    1: InstrumentString:='Acoustic Grand Piano';
    2: InstrumentString:='Bright Acoustic Piano';
    3: InstrumentString:='Electric Grand Piano';
    4: InstrumentString:='Honky-tonk Piano';
    5: InstrumentString:='Electric Piano 1';
    6: InstrumentString:='Electric Piano 2';
    7: InstrumentString:='Harpsichord';
    8: InstrumentString:='Clavinet';
    9: InstrumentString:='Celesta';
    10: InstrumentString:='Glockenspiel';
    11: InstrumentString:='Music Box';
    12: InstrumentString:='Vibraphone';
    13: InstrumentString:='Marimba';
    14: InstrumentString:='Xylophone';
    15: InstrumentString:='Tubular Bells';
    16: InstrumentString:='Dulcimer';
    17: InstrumentString:='Drawbar Organ';
    18: InstrumentString:='Percussive Organ';
    19: InstrumentString:='Rock Organ';
    20: InstrumentString:='Church Organ';
    21: InstrumentString:='Reed Organ';
    22: InstrumentString:='Accordion';
    23: InstrumentString:='Harmonica';
    24: InstrumentString:='Tango Accordion';
    25: InstrumentString:='Acoustic Guitar (nylon)';
    26: InstrumentString:='Acoustic Guitar (steel)';
    27: InstrumentString:='Electric Guitar (jazz)';
    28: InstrumentString:='Electric Guitar (clean)';
    29: InstrumentString:='Electric Guitar (muted)';
    30: InstrumentString:='Overdriven Guitar';
    31: InstrumentString:='Distortion Guitar';
    32: InstrumentString:='Guitar harmonics';
    33: InstrumentString:='Acoustic Bass';
    34: InstrumentString:='Electric Bass (finger)';
    35: InstrumentString:='Electric Bass (pick)';
    36: InstrumentString:='Fretless Bass';
    37: InstrumentString:='Slap Bass 1';
    38: InstrumentString:='Slap Bass 2';
    39: InstrumentString:='Synth Bass 1';
    40: InstrumentString:='Synth Bass 2';
    41: InstrumentString:='Violin';
    42: InstrumentString:='Viola';
    43: InstrumentString:='Cello';
    44: InstrumentString:='Contrabass';
    45: InstrumentString:='Tremolo Strings';
    46: InstrumentString:='Pizzicato Strings';
    47: InstrumentString:='Orchestral Harp';
    48: InstrumentString:='Timpani';
    49: InstrumentString:='String Ensemble 1';
    50: InstrumentString:='String Ensemble 2';
    51: InstrumentString:='Synth Strings 1';
    52: InstrumentString:='Synth Strings 2';
    53: InstrumentString:='Choir Aahs';
    54: InstrumentString:='Voice Oohs';
    55: InstrumentString:='Synth Voice';
    56: InstrumentString:='Orchestra Hit';
    57: InstrumentString:='Trumpet';
    58: InstrumentString:='Trombone';
    59: InstrumentString:='Tuba';
    60: InstrumentString:='Muted Trumpet';
    61: InstrumentString:='French Horn';
    62: InstrumentString:='Brass Section';
    63: InstrumentString:='Synth Brass 1';
    64: InstrumentString:='Synth Brass 2';
    65: InstrumentString:='Soprano Sax';
    66: InstrumentString:='Alto Sax';
    67: InstrumentString:='Tenor Sax';
    68: InstrumentString:='Baritone Sax';
    69: InstrumentString:='Oboe';
    70: InstrumentString:='English Horn';
    71: InstrumentString:='Bassoon';
    72: InstrumentString:='Clarinet';
    73: InstrumentString:='Piccolo';
    74: InstrumentString:='Flute';
    75: InstrumentString:='Recorder';
    76: InstrumentString:='Pan Flute';
    77: InstrumentString:='Blown Bottle';
    78: InstrumentString:='Shakuhachi';
    79: InstrumentString:='Whistle';
    80: InstrumentString:='Ocarina';
    81: InstrumentString:='Lead 1 (square)';
    82: InstrumentString:='Lead 2 (sawtooth)';
    83: InstrumentString:='Lead 3 (calliope)';
    84: InstrumentString:='Lead 4 (chiff)';
    85: InstrumentString:='Lead 5 (charang)';
    86: InstrumentString:='Lead 6 (voice)';
    87: InstrumentString:='Lead 7 (fifths)';
    88: InstrumentString:='Lead 8 (bass + lead)';
    89: InstrumentString:=' Pad 1 (new age)';
    90: InstrumentString:=' Pad 2 (warm)';
    91: InstrumentString:=' Pad 3 (polysynth)';
    92: InstrumentString:=' Pad 4 (choir)';
    93: InstrumentString:=' Pad 5 (bowed)';
    94: InstrumentString:=' Pad 6 (metallic)';
    95: InstrumentString:=' Pad 7 (halo)';
    96: InstrumentString:=' Pad 8 (sweep)';
    97: InstrumentString:=' FX 1 (rain)';
    98: InstrumentString:=' FX 2 (soundtrack)';
    99: InstrumentString:=' FX 3 (crystal)';
    100: InstrumentString:=' FX 4 (atmosphere)';
    101: InstrumentString:=' FX 5 (brightness)';
    102: InstrumentString:=' FX 6 (goblins)';
    103: InstrumentString:=' FX 7 (echoes)';
    104: InstrumentString:=' FX 8 (sci-fi)';
    105: InstrumentString:=' Sitar';
    106: InstrumentString:=' Banjo';
    107: InstrumentString:=' Shamisen';
    108: InstrumentString:=' Koto';
    109: InstrumentString:=' Kalimba';
    110: InstrumentString:=' Bag pipe';
    111: InstrumentString:=' Fiddle';
    112: InstrumentString:=' Shanai';
    113: InstrumentString:=' Tinkle Bell';
    114: InstrumentString:=' Agogo';
    115: InstrumentString:=' Steel Drums';
    116: InstrumentString:=' Woodblock';
    117: InstrumentString:=' Taiko Drum';
    118: InstrumentString:=' Melodic Tom';
    119: InstrumentString:=' Synth Drum';
    120: InstrumentString:=' Reverse Cymbal';
    121: InstrumentString:=' Guitar Fret Noise';
    122: InstrumentString:=' Breath Noise';
    123: InstrumentString:=' Seashore';
    124: InstrumentString:=' Bird Tweet';
    125: InstrumentString:=' Telephone Ring';
    126: InstrumentString:=' Helicopter';
    127: InstrumentString:=' Applause';
    128: InstrumentString:=' Gunshot';
    end
  end;



//---------------------------------------------------------------------------
//
//     Function:   MMSysErrorString
//
//     Purpose:    To produce a text for MM System Errors
//
//     Parameters: i = Error number
//
//     Returns:    a description text for the error
//
//     Notes:      None
//
//---------------------------------------------------------------------------

function TFormMidiGui.MMSysErrorString(i: integer): string;

  begin
    case i of
    0: MMSysErrorString:='No Error';
    1: MMSysErrorString:='Unspecified Error';
    2: MMSysErrorString:='Device ID out of range';
    3: MMSysErrorString:='Driver failed enable';
    4: MMSysErrorString:='Device already allocated';
    5: MMSysErrorString:='Device handle is invalid';
    6: MMSysErrorString:='No device driver present';
    7: MMSysErrorString:='Memory allocation error';
    8: MMSysErrorString:='Function is not supported';
    9: MMSysErrorString:='Error value out of range';
    10: MMSysErrorString:='Invalid flag passed';
    11: MMSysErrorString:='Invalid parameter passed';
    12: MMSysErrorString:='Handle being used simultaneously on another thread';
    13: MMSysErrorString:='Specified alias not found';
    14: MMSysErrorString:='Bad registry database';
    15: MMSysErrorString:='Registry key not found';
    16: MMSysErrorString:='Registry read error';
    17: MMSysErrorString:='Registry write error';
    18: MMSysErrorString:='Registry delete error';
    19: MMSysErrorString:='Registry value not found';
    20: MMSysErrorString:='Driver does not call DriverCallback';
    end
  end;

//---------------------------------------------------------------------------
//
//     Function:   MenuItemTextClick
//
//     Purpose:    When selecting the menu item "Text" then show the window
//                 with the song text.
//
//     Parameters: i = Instrument number
//
//     Returns:    a description text for the instrument
//
//     Notes:      Only avaiable when the midi file contains text
//
//---------------------------------------------------------------------------

procedure TFormMidiGui.MenuItemTextClick(Sender: TObject);

  begin
  FormText.Visible:=true;
  end;

procedure TFormMidiGui.MenuItemExitAndDeleteOptionsClick(Sender: TObject);

var
{$ifndef FPC}
  EnvC: CString;            // Environmentvariable as C string
{$endif}
  UserDir: string;

  begin
{$ifdef FPC}
  UserDir:=GetEnvironmentVariable('USERPROFILE');
{$else}
  GetEnvironmentVariable('USERPROFILE',@EnvC,255);
  UserDir:=PascalString(EnvC);
{$endif}
  UserProfile:=UserDir+'\MidiOptions';
  UserProfile:=UserProfile+'\'+ExtractFileName(FileName)+'.options';
  DeleteFile(UserProfile);
  Halt(0);
  end;


procedure TFormMidiGui.MenuItemSaveMidiClick(Sender: TObject);

  begin
  SaveMidiData;
  end;

function CStringToPasString(s1: array of char): string;

var s2: string;
    i: integer;

  begin
  s2:='';
  i:=0;
  while s1[i]<>chr(0) do
    begin
    s2:=s2+s1[i];
    inc(i);
    end;
  CStringToPasString:=s2;
  end;

{$ifdef FPC}
function GetEnvVariable(EnvVar: String): String;

  begin
  GetEnvVariable:=GetEnvironmentVariable(EnvVar);
  end;

{$endif}

procedure TFormMidiGui.OnMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);

  begin
  if SystemState=MidiPlaying then
    begin
    MidiPositionForwardNext:=(((X-ProgressBarMidi.Left)*200)+200) div ProgressBarMidi.Width;
    if MidiPositionForwardNext>=200 then
      MidiPositionForwardNext:=199;
    if MidiPositionForwardNext<0 then
      MidiPositionForwardNext:=0;

    MidiProgress:=0;
    ProgressBarMidi.Position:=0;
    MidiPositionChange:=true;
    MidiDeltaTotalOut:=0;
    end;
  end;

procedure TFormMidiGui.MenuFileClick(Sender: TObject);

  begin
  MenuItemSaveMidi.Enabled:=FileName<>'';
  end;

procedure TFormMidiGui.MenuItemSaveTextClick(Sender: TObject);


  begin
  if TextsAreInitialised then
    begin
    FormText.CopyTextToFile;
    end;

  end;

end.

